<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Algorithms_in_C++: sorting Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Algorithms_in_C++<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">Set of algorithms implemented in C++.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">sorting Namespace Reference<div class="ingroups"><a class="el" href="group__sorting.html">Sorting Algorithm</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>for working with vectors  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a034d8b276518a902962e87d3158b64fd" id="r_a034d8b276518a902962e87d3158b64fd"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a034d8b276518a902962e87d3158b64fd"><td class="memTemplItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a034d8b276518a902962e87d3158b64fd">binary_search</a> (std::vector&lt; T &gt; &amp;arr, T val, int64_t low, int64_t high)</td></tr>
<tr class="memdesc:a034d8b276518a902962e87d3158b64fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary search function to find the most suitable pace for an element.  <br /></td></tr>
<tr class="separator:a034d8b276518a902962e87d3158b64fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4bc75cca6dd8294af2d0e328006c68" id="r_a5f4bc75cca6dd8294af2d0e328006c68"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5f4bc75cca6dd8294af2d0e328006c68"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5f4bc75cca6dd8294af2d0e328006c68">insertionSort_binsrch</a> (std::vector&lt; T &gt; &amp;arr)</td></tr>
<tr class="memdesc:a5f4bc75cca6dd8294af2d0e328006c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insertion sort function to sort the vector.  <br /></td></tr>
<tr class="separator:a5f4bc75cca6dd8294af2d0e328006c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bfe11bd4703eacd1dab93f25ec639c5" id="r_a7bfe11bd4703eacd1dab93f25ec639c5"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a7bfe11bd4703eacd1dab93f25ec639c5"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7bfe11bd4703eacd1dab93f25ec639c5">shuffle</a> (std::array&lt; T, N &gt; arr)</td></tr>
<tr class="separator:a7bfe11bd4703eacd1dab93f25ec639c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc6ee160142cd017f8c4b213437d0fd" id="r_affc6ee160142cd017f8c4b213437d0fd"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:affc6ee160142cd017f8c4b213437d0fd"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#affc6ee160142cd017f8c4b213437d0fd">randomized_bogosort</a> (std::array&lt; T, N &gt; arr)</td></tr>
<tr class="separator:affc6ee160142cd017f8c4b213437d0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8bc626eb57acae24a94636a23af6a1" id="r_a2f8bc626eb57acae24a94636a23af6a1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2f8bc626eb57acae24a94636a23af6a1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2f8bc626eb57acae24a94636a23af6a1">gnomeSort</a> (T *arr, int size)</td></tr>
<tr class="separator:a2f8bc626eb57acae24a94636a23af6a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3677f87b5b4756bc77e9e34c5f27935" id="r_aa3677f87b5b4756bc77e9e34c5f27935"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t size&gt; </td></tr>
<tr class="memitem:aa3677f87b5b4756bc77e9e34c5f27935"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa3677f87b5b4756bc77e9e34c5f27935">gnomeSort</a> (std::array&lt; T, size &gt; arr)</td></tr>
<tr class="separator:aa3677f87b5b4756bc77e9e34c5f27935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78cb2f3b97b6db2c062b2a1df05c9ea9" id="r_a78cb2f3b97b6db2c062b2a1df05c9ea9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a78cb2f3b97b6db2c062b2a1df05c9ea9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a78cb2f3b97b6db2c062b2a1df05c9ea9">insertionSort</a> (T *arr, int n)</td></tr>
<tr class="memdesc:a78cb2f3b97b6db2c062b2a1df05c9ea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insertion Sort Function.  <br /></td></tr>
<tr class="separator:a78cb2f3b97b6db2c062b2a1df05c9ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe6bac9e03f58abcc2ce26ef3de1b5f" id="r_a8fe6bac9e03f58abcc2ce26ef3de1b5f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8fe6bac9e03f58abcc2ce26ef3de1b5f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8fe6bac9e03f58abcc2ce26ef3de1b5f">insertionSort</a> (std::vector&lt; T &gt; *arr)</td></tr>
<tr class="memdesc:a8fe6bac9e03f58abcc2ce26ef3de1b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insertion Sort for a vector.  <br /></td></tr>
<tr class="separator:a8fe6bac9e03f58abcc2ce26ef3de1b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26de383227859210f14dcf12201a079" id="r_aa26de383227859210f14dcf12201a079"><td class="memTemplParams" colspan="2">template&lt;class Iterator &gt; </td></tr>
<tr class="memitem:aa26de383227859210f14dcf12201a079"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa26de383227859210f14dcf12201a079">merge</a> (Iterator l, Iterator r, const Iterator e, char b[])</td></tr>
<tr class="memdesc:aa26de383227859210f14dcf12201a079"><td class="mdescLeft">&#160;</td><td class="mdescRight">merges 2 sorted adjacent segments into a larger sorted segment  <br /></td></tr>
<tr class="separator:aa26de383227859210f14dcf12201a079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140d913e42fb94176a0b2c8b29a80420" id="r_a140d913e42fb94176a0b2c8b29a80420"><td class="memTemplParams" colspan="2">template&lt;class Iterator &gt; </td></tr>
<tr class="memitem:a140d913e42fb94176a0b2c8b29a80420"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a140d913e42fb94176a0b2c8b29a80420">non_recursive_merge_sort</a> (const Iterator first, const Iterator last, const size_t n)</td></tr>
<tr class="memdesc:a140d913e42fb94176a0b2c8b29a80420"><td class="mdescLeft">&#160;</td><td class="mdescRight">bottom-up merge sort which sorts elements in a non-decreasing order  <br /></td></tr>
<tr class="separator:a140d913e42fb94176a0b2c8b29a80420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27236b8d3df3832e1f1225576a122534" id="r_a27236b8d3df3832e1f1225576a122534"><td class="memTemplParams" colspan="2">template&lt;class Iterator &gt; </td></tr>
<tr class="memitem:a27236b8d3df3832e1f1225576a122534"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a27236b8d3df3832e1f1225576a122534">non_recursive_merge_sort</a> (const Iterator first, const size_t n)</td></tr>
<tr class="memdesc:a27236b8d3df3832e1f1225576a122534"><td class="mdescLeft">&#160;</td><td class="mdescRight">bottom-up merge sort which sorts elements in a non-decreasing order  <br /></td></tr>
<tr class="separator:a27236b8d3df3832e1f1225576a122534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97f4dd815654c4682f564afd718e824" id="r_ae97f4dd815654c4682f564afd718e824"><td class="memTemplParams" colspan="2">template&lt;class Iterator &gt; </td></tr>
<tr class="memitem:ae97f4dd815654c4682f564afd718e824"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae97f4dd815654c4682f564afd718e824">non_recursive_merge_sort</a> (const Iterator first, const Iterator last)</td></tr>
<tr class="memdesc:ae97f4dd815654c4682f564afd718e824"><td class="mdescLeft">&#160;</td><td class="mdescRight">bottom-up merge sort which sorts elements in a non-decreasing order  <br /></td></tr>
<tr class="separator:ae97f4dd815654c4682f564afd718e824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9e1b21a1684585e9e50f9afe4d53a3" id="r_a0e9e1b21a1684585e9e50f9afe4d53a3"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a0e9e1b21a1684585e9e50f9afe4d53a3"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; int, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0e9e1b21a1684585e9e50f9afe4d53a3">pigeonSort</a> (std::array&lt; int, N &gt; arr)</td></tr>
<tr class="separator:a0e9e1b21a1684585e9e50f9afe4d53a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f59fe72dacc1f1218ef3c303d843168" id="r_a9f59fe72dacc1f1218ef3c303d843168"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9f59fe72dacc1f1218ef3c303d843168"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9f59fe72dacc1f1218ef3c303d843168">quicksort</a> (std::vector&lt; T &gt; *arr, int32_t low, int32_t high)</td></tr>
<tr class="separator:a9f59fe72dacc1f1218ef3c303d843168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb67c2f91c98cf4464f75b5882022de" id="r_a6eb67c2f91c98cf4464f75b5882022de"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6eb67c2f91c98cf4464f75b5882022de"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6eb67c2f91c98cf4464f75b5882022de">quicksort</a> (std::vector&lt; T &gt; arr, int32_t low, int32_t high)</td></tr>
<tr class="separator:a6eb67c2f91c98cf4464f75b5882022de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac8f44b28b4aa96444383030b28f8b34" id="r_aac8f44b28b4aa96444383030b28f8b34"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac8f44b28b4aa96444383030b28f8b34">partition</a> (std::vector&lt; int &gt; &amp;arr, int start, int end)</td></tr>
<tr class="memdesc:aac8f44b28b4aa96444383030b28f8b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">The partition function sorts the array from start to end and uses the last element as the pivot.  <br /></td></tr>
<tr class="separator:aac8f44b28b4aa96444383030b28f8b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263595fd9a0163b5b997b89fab3a0dc5" id="r_a263595fd9a0163b5b997b89fab3a0dc5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a263595fd9a0163b5b997b89fab3a0dc5">iterativeQuickSort</a> (std::vector&lt; int &gt; &amp;arr)</td></tr>
<tr class="memdesc:a263595fd9a0163b5b997b89fab3a0dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main sorting function.  <br /></td></tr>
<tr class="separator:a263595fd9a0163b5b997b89fab3a0dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a775d99dbbb94c130a973df0cfddcf" id="r_ae3a775d99dbbb94c130a973df0cfddcf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae3a775d99dbbb94c130a973df0cfddcf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae3a775d99dbbb94c130a973df0cfddcf">recursive_bubble_sort</a> (std::vector&lt; T &gt; *nums, uint64_t n)</td></tr>
<tr class="memdesc:ae3a775d99dbbb94c130a973df0cfddcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an implementation of the recursive_bubble_sort. A vector is passed to the function which is then dereferenced, so that the changes are reflected in the original vector. It also accepts a second parameter of type <code>int</code> and name <code>n</code>, which is the size of the array.  <br /></td></tr>
<tr class="separator:ae3a775d99dbbb94c130a973df0cfddcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06af4f0dae2de2a2ae5b797d7aa26755" id="r_a06af4f0dae2de2a2ae5b797d7aa26755"><td class="memItemLeft" align="right" valign="top"><a id="a06af4f0dae2de2a2ae5b797d7aa26755" name="a06af4f0dae2de2a2ae5b797d7aa26755"></a>
std::vector&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>selectionSort</b> (const std::vector&lt; uint64_t &gt; &amp;arr, uint64_t len)</td></tr>
<tr class="separator:a06af4f0dae2de2a2ae5b797d7aa26755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5669396c6a6b1e14b97589b6e37980aa" id="r_a5669396c6a6b1e14b97589b6e37980aa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5669396c6a6b1e14b97589b6e37980aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5669396c6a6b1e14b97589b6e37980aa">shell_sort</a> (T *arr, size_t LEN)</td></tr>
<tr class="separator:a5669396c6a6b1e14b97589b6e37980aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d76603c54d3dc56146e92d10a043924" id="r_a4d76603c54d3dc56146e92d10a043924"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a4d76603c54d3dc56146e92d10a043924"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4d76603c54d3dc56146e92d10a043924">shell_sort</a> (T(&amp;arr)[N])</td></tr>
<tr class="separator:a4d76603c54d3dc56146e92d10a043924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c5b92cbfe73f63f6074c61b0a45331" id="r_af2c5b92cbfe73f63f6074c61b0a45331"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af2c5b92cbfe73f63f6074c61b0a45331"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af2c5b92cbfe73f63f6074c61b0a45331">shell_sort</a> (std::vector&lt; T &gt; *arr)</td></tr>
<tr class="separator:af2c5b92cbfe73f63f6074c61b0a45331"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>for working with vectors </p>
<p>for io operations</p>
<p>for std::is_sorted</p>
<p>for returning multiple values form a function at once</p>
<p>Sorting Algorithms.</p>
<p>for using std::vector</p>
<p>for std::vector</p>
<p>Sorting algorithms.</p>
<p>for algorithm functions for assert for IO operations</p>
<p>Sorting algorithms</p>
<p>for assert for typedef datatype uint64_t for IO operations</p>
<p>Sorting algorithms</p>
<p>for std::is_sorted, std::swap for assert for io operations</p>
<p>Sorting algorithms</p>
<p>for std::is_sorted for assert for std::swap and io operations</p>
<p>@breif Sorting algorithms</p>
<p>Sorting algorithms</p>
<p>for std::is_sorted for assert function in testing for std::cout and std::endl</p>
<p>Contains sorting algorithms</p>
<p>for std::is_sorted for std::assert for std::time for IO operations</p>
<p>Sorting algorithms</p>
<p>for std::cout for std::vector for std::stack for std::is_sorted for assert</p>
<p>header files for collection of functions for a macro called assert which can be used to verify assumptions for io operations</p>
<p>Sorting algorithms</p>
<p>for std::is_sorted(), std::swap() for std::array for assert for initializing random number generator for IO operations</p>
<p>Sorting algorithms</p>
<p>for assert for IO operations for std::vector for std::array</p>
<p>Sorting algorithms</p>
<p>for std::is_sorted for std::assert for IO operations</p>
<p>for std::is_sorted for assert for std::swap and io operations</p>
<p>Sorting algorithms</p>
<p>for std::is_sorted, std::swap for assert for IO operations</p>
<p>Sorting algorithms </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a034d8b276518a902962e87d3158b64fd" name="a034d8b276518a902962e87d3158b64fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a034d8b276518a902962e87d3158b64fd">&#9670;&#160;</a></span>binary_search()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int64_t sorting::binary_search </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>low</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>high</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary search function to find the most suitable pace for an element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The generic data type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>The actual vector in which we are searching a suitable place for the element.</td></tr>
    <tr><td class="paramname">val</td><td>The value for which suitable place is to be found. </td></tr>
    <tr><td class="paramname">low</td><td>The lower bound of the range we are searching in. </td></tr>
    <tr><td class="paramname">high</td><td>The upper bound of the range we are searching in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of most suitable position of val. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacesorting_a034d8b276518a902962e87d3158b64fd_cgraph.svg" width="160" height="60"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="aa3677f87b5b4756bc77e9e34c5f27935" name="aa3677f87b5b4756bc77e9e34c5f27935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3677f87b5b4756bc77e9e34c5f27935">&#9670;&#160;</a></span>gnomeSort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, size &gt; sorting::gnomeSort </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, size &gt;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This implementation is for a C++-style array input. The function argument is a pass-by-value and hence a copy of the array gets created which is then modified by the function and returned. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of data variables in the array </td></tr>
    <tr><td class="paramname">size</td><td>size of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arr</td><td>our array of elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with elements sorted </dd></dl>

</div>
</div>
<a id="a2f8bc626eb57acae24a94636a23af6a1" name="a2f8bc626eb57acae24a94636a23af6a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f8bc626eb57acae24a94636a23af6a1">&#9670;&#160;</a></span>gnomeSort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sorting::gnomeSort </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This implementation is for a C-style array input that gets modified in place. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">arr</td><td>our array of elements. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">size</td><td>size of given array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8fe6bac9e03f58abcc2ce26ef3de1b5f" name="a8fe6bac9e03f58abcc2ce26ef3de1b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fe6bac9e03f58abcc2ce26ef3de1b5f">&#9670;&#160;</a></span>insertionSort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sorting::insertionSort </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>arr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insertion Sort for a vector. </p>
<p>Insertion Sort Function</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">arr</td><td>pointer to array to be sorted</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the vector elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">arr</td><td>Pointer to the vector to be sorted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a78cb2f3b97b6db2c062b2a1df05c9ea9" name="a78cb2f3b97b6db2c062b2a1df05c9ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78cb2f3b97b6db2c062b2a1df05c9ea9">&#9670;&#160;</a></span>insertionSort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sorting::insertionSort </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insertion Sort Function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">arr</td><td>Array to be sorted </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>Size of Array</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the array elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">arr</td><td>Array to be sorted </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>Size of the array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f4bc75cca6dd8294af2d0e328006c68" name="a5f4bc75cca6dd8294af2d0e328006c68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f4bc75cca6dd8294af2d0e328006c68">&#9670;&#160;</a></span>insertionSort_binsrch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sorting::insertionSort_binsrch </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insertion sort function to sort the vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The generic data type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>The actual vector to sort. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Void. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacesorting_a5f4bc75cca6dd8294af2d0e328006c68_cgraph.svg" width="350" height="68"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a263595fd9a0163b5b997b89fab3a0dc5" name="a263595fd9a0163b5b997b89fab3a0dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a263595fd9a0163b5b997b89fab3a0dc5">&#9670;&#160;</a></span>iterativeQuickSort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sorting::iterativeQuickSort </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The main sorting function. </p>
<p>The iterative quick sort uses the stack instead of recursion for saving and restoring the environment between calls. It does not need the end and start params, because it is not recursive. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>array to be sorted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacesorting_a263595fd9a0163b5b997b89fab3a0dc5_cgraph.svg" width="346" height="184"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="aa26de383227859210f14dcf12201a079" name="aa26de383227859210f14dcf12201a079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa26de383227859210f14dcf12201a079">&#9670;&#160;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sorting::merge </td>
          <td>(</td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>l</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iterator</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>b</em></span>[]&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>merges 2 sorted adjacent segments into a larger sorted segment </p>
<p>best-case = worst-case = O(n) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>points to the left part </td></tr>
    <tr><td class="paramname">r</td><td>points to the right part, end of left part </td></tr>
    <tr><td class="paramname">e</td><td>points to end of right part </td></tr>
    <tr><td class="paramname">b</td><td>points at the buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae97f4dd815654c4682f564afd718e824" name="ae97f4dd815654c4682f564afd718e824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae97f4dd815654c4682f564afd718e824">&#9670;&#160;</a></span>non_recursive_merge_sort() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sorting::non_recursive_merge_sort </td>
          <td>(</td>
          <td class="paramtype">const Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>bottom-up merge sort which sorts elements in a non-decreasing order </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>points to the first element </td></tr>
    <tr><td class="paramname">last</td><td>points to 1-step past the last element </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacesorting_ae97f4dd815654c4682f564afd718e824_cgraph.svg" width="510" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a140d913e42fb94176a0b2c8b29a80420" name="a140d913e42fb94176a0b2c8b29a80420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a140d913e42fb94176a0b2c8b29a80420">&#9670;&#160;</a></span>non_recursive_merge_sort() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sorting::non_recursive_merge_sort </td>
          <td>(</td>
          <td class="paramtype">const Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>bottom-up merge sort which sorts elements in a non-decreasing order </p>
<p>sorts elements non-recursively by breaking them into small segments, merging adjacent segments into larger sorted segments, then increasing the sizes of segments by factors of 2 and repeating the same process. best-case = worst-case = O(n log(n)) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>points to the first element </td></tr>
    <tr><td class="paramname">last</td><td>points to 1-step past the last element </td></tr>
    <tr><td class="paramname">n</td><td>the number of elements </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacesorting_a140d913e42fb94176a0b2c8b29a80420_cgraph.svg" width="312" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a27236b8d3df3832e1f1225576a122534" name="a27236b8d3df3832e1f1225576a122534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27236b8d3df3832e1f1225576a122534">&#9670;&#160;</a></span>non_recursive_merge_sort() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sorting::non_recursive_merge_sort </td>
          <td>(</td>
          <td class="paramtype">const Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>bottom-up merge sort which sorts elements in a non-decreasing order </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>points to the first element </td></tr>
    <tr><td class="paramname">n</td><td>the number of elements </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacesorting_a27236b8d3df3832e1f1225576a122534_cgraph.svg" width="510" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="aac8f44b28b4aa96444383030b28f8b34" name="aac8f44b28b4aa96444383030b28f8b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac8f44b28b4aa96444383030b28f8b34">&#9670;&#160;</a></span>partition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sorting::partition </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The partition function sorts the array from start to end and uses the last element as the pivot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>the array to be sorted </td></tr>
    <tr><td class="paramname">start</td><td>starting index </td></tr>
    <tr><td class="paramname">end</td><td>ending index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int next index of the pivot </dd></dl>

</div>
</div>
<a id="a0e9e1b21a1684585e9e50f9afe4d53a3" name="a0e9e1b21a1684585e9e50f9afe4d53a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e9e1b21a1684585e9e50f9afe4d53a3">&#9670;&#160;</a></span>pigeonSort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; int, N &gt; sorting::pigeonSort </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; int, N &gt;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pigeonhole sorting of array of size n The function will sort the array through Pigeonhole algorithm and print </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>unsorted array of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sorted array of elements </dd></dl>

</div>
</div>
<a id="a9f59fe72dacc1f1218ef3c303d843168" name="a9f59fe72dacc1f1218ef3c303d843168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f59fe72dacc1f1218ef3c303d843168">&#9670;&#160;</a></span>quicksort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sorting::quicksort </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>low</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>high</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>3-way partition based quick sort. This function accepts array pointer and modified the input array. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of data in the vector array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">arr</td><td>vector array to sort </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">low</td><td>lower limit of window to partition </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">high</td><td>upper limit of window to partition </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacesorting_a9f59fe72dacc1f1218ef3c303d843168_cgraph.svg" width="132" height="60"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a6eb67c2f91c98cf4464f75b5882022de" name="a6eb67c2f91c98cf4464f75b5882022de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eb67c2f91c98cf4464f75b5882022de">&#9670;&#160;</a></span>quicksort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; sorting::quicksort </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>low</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>high</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>3-way partition based quick sort. This function accepts array by value and creates a copy of it. The array copy gets sorted and returned by the function. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of data in the vector array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arr</td><td>vector array to sort </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">low</td><td>lower limit of window to partition </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">high</td><td>upper limit of window to partition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sorted array vector </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacesorting_a6eb67c2f91c98cf4464f75b5882022de_cgraph.svg" width="302" height="60"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="affc6ee160142cd017f8c4b213437d0fd" name="affc6ee160142cd017f8c4b213437d0fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affc6ee160142cd017f8c4b213437d0fd">&#9670;&#160;</a></span>randomized_bogosort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, N &gt; sorting::randomized_bogosort </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, N &gt;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implement randomized Bogosort algorithm and sort the elements of a given array. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>typename of the array </td></tr>
    <tr><td class="paramname">N</td><td>length of array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>array to sort </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new array with elements sorted from a given array </dd></dl>

</div>
</div>
<a id="ae3a775d99dbbb94c130a973df0cfddcf" name="ae3a775d99dbbb94c130a973df0cfddcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a775d99dbbb94c130a973df0cfddcf">&#9670;&#160;</a></span>recursive_bubble_sort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sorting::recursive_bubble_sort </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>nums</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an implementation of the recursive_bubble_sort. A vector is passed to the function which is then dereferenced, so that the changes are reflected in the original vector. It also accepts a second parameter of type <code>int</code> and name <code>n</code>, which is the size of the array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of data variables in the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nums</td><td>our array of elements. </td></tr>
    <tr><td class="paramname">n</td><td>size of the array </td></tr>
  </table>
  </dd>
</dl>
<p>&lt; base case; when size of the array is 1</p>
<p>&lt; iterating over the entire array</p>
<p>&lt; if a larger number appears before the smaller one, swap them.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacesorting_ae3a775d99dbbb94c130a973df0cfddcf_cgraph.svg" width="132" height="76"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="af2c5b92cbfe73f63f6074c61b0a45331" name="af2c5b92cbfe73f63f6074c61b0a45331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2c5b92cbfe73f63f6074c61b0a45331">&#9670;&#160;</a></span>shell_sort() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sorting::shell_sort </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>arr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>function overload - when input array is of type std::vector, simply send the data content and the data length to the above function. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacesorting_af2c5b92cbfe73f63f6074c61b0a45331_cgraph.svg" width="308" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a5669396c6a6b1e14b97589b6e37980aa" name="a5669396c6a6b1e14b97589b6e37980aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5669396c6a6b1e14b97589b6e37980aa">&#9670;&#160;</a></span>shell_sort() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sorting::shell_sort </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>LEN</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Optimized algorithm - takes half the time by utilizing Mar </p>

</div>
</div>
<a id="a4d76603c54d3dc56146e92d10a043924" name="a4d76603c54d3dc56146e92d10a043924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d76603c54d3dc56146e92d10a043924">&#9670;&#160;</a></span>shell_sort() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sorting::shell_sort </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>function overload - when input array is of a known length array type </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacesorting_a4d76603c54d3dc56146e92d10a043924_cgraph.svg" width="308" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a7bfe11bd4703eacd1dab93f25ec639c5" name="a7bfe11bd4703eacd1dab93f25ec639c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bfe11bd4703eacd1dab93f25ec639c5">&#9670;&#160;</a></span>shuffle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, N &gt; sorting::shuffle </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, N &gt;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to shuffle the elements of an array. (for reference) </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>typename of the array </td></tr>
    <tr><td class="paramname">N</td><td>length of array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>array to shuffle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new array with elements shuffled from a given array </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
