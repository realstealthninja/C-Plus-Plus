\doxysection{sorting Namespace Reference}
\hypertarget{namespacesorting}{}\label{namespacesorting}\index{sorting@{sorting}}


for working with vectors  


\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$class T $>$ }\\int64\+\_\+t \mbox{\hyperlink{namespacesorting_a034d8b276518a902962e87d3158b64fd}{binary\+\_\+search}} (std\+::vector$<$ T $>$ \&arr, T val, int64\+\_\+t low, int64\+\_\+t high)
\begin{DoxyCompactList}\small\item\em Binary search function to find the most suitable pace for an element. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacesorting_a5f4bc75cca6dd8294af2d0e328006c68}{insertion\+Sort\+\_\+binsrch}} (std\+::vector$<$ T $>$ \&arr)
\begin{DoxyCompactList}\small\item\em Insertion sort function to sort the vector. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\std\+::array$<$ T, N $>$ \mbox{\hyperlink{namespacesorting_a7bfe11bd4703eacd1dab93f25ec639c5}{shuffle}} (std\+::array$<$ T, N $>$ arr)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\std\+::array$<$ T, N $>$ \mbox{\hyperlink{namespacesorting_affc6ee160142cd017f8c4b213437d0fd}{randomized\+\_\+bogosort}} (std\+::array$<$ T, N $>$ arr)
\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacesorting_a2f8bc626eb57acae24a94636a23af6a1}{gnome\+Sort}} (T \texorpdfstring{$\ast$}{*}arr, int size)
\item 
{\footnotesize template$<$typename T , size\+\_\+t size$>$ }\\std\+::array$<$ T, size $>$ \mbox{\hyperlink{namespacesorting_aa3677f87b5b4756bc77e9e34c5f27935}{gnome\+Sort}} (std\+::array$<$ T, size $>$ arr)
\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacesorting_a78cb2f3b97b6db2c062b2a1df05c9ea9}{insertion\+Sort}} (T \texorpdfstring{$\ast$}{*}arr, int n)
\begin{DoxyCompactList}\small\item\em Insertion Sort Function. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacesorting_a8fe6bac9e03f58abcc2ce26ef3de1b5f}{insertion\+Sort}} (std\+::vector$<$ T $>$ \texorpdfstring{$\ast$}{*}arr)
\begin{DoxyCompactList}\small\item\em Insertion Sort for a vector. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Iterator $>$ }\\void \mbox{\hyperlink{namespacesorting_aa26de383227859210f14dcf12201a079}{merge}} (Iterator l, Iterator r, const Iterator e, char b\mbox{[}$\,$\mbox{]})
\begin{DoxyCompactList}\small\item\em merges 2 sorted adjacent segments into a larger sorted segment \end{DoxyCompactList}\item 
{\footnotesize template$<$class Iterator $>$ }\\void \mbox{\hyperlink{namespacesorting_a140d913e42fb94176a0b2c8b29a80420}{non\+\_\+recursive\+\_\+merge\+\_\+sort}} (const Iterator first, const Iterator last, const size\+\_\+t n)
\begin{DoxyCompactList}\small\item\em bottom-\/up merge sort which sorts elements in a non-\/decreasing order \end{DoxyCompactList}\item 
{\footnotesize template$<$class Iterator $>$ }\\void \mbox{\hyperlink{namespacesorting_a27236b8d3df3832e1f1225576a122534}{non\+\_\+recursive\+\_\+merge\+\_\+sort}} (const Iterator first, const size\+\_\+t n)
\begin{DoxyCompactList}\small\item\em bottom-\/up merge sort which sorts elements in a non-\/decreasing order \end{DoxyCompactList}\item 
{\footnotesize template$<$class Iterator $>$ }\\void \mbox{\hyperlink{namespacesorting_ae97f4dd815654c4682f564afd718e824}{non\+\_\+recursive\+\_\+merge\+\_\+sort}} (const Iterator first, const Iterator last)
\begin{DoxyCompactList}\small\item\em bottom-\/up merge sort which sorts elements in a non-\/decreasing order \end{DoxyCompactList}\item 
{\footnotesize template$<$std\+::size\+\_\+t N$>$ }\\std\+::array$<$ int, N $>$ \mbox{\hyperlink{namespacesorting_a0e9e1b21a1684585e9e50f9afe4d53a3}{pigeon\+Sort}} (std\+::array$<$ int, N $>$ arr)
\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacesorting_a9f59fe72dacc1f1218ef3c303d843168}{quicksort}} (std\+::vector$<$ T $>$ \texorpdfstring{$\ast$}{*}arr, int32\+\_\+t low, int32\+\_\+t high)
\item 
{\footnotesize template$<$typename T $>$ }\\std\+::vector$<$ T $>$ \mbox{\hyperlink{namespacesorting_a6eb67c2f91c98cf4464f75b5882022de}{quicksort}} (std\+::vector$<$ T $>$ arr, int32\+\_\+t low, int32\+\_\+t high)
\item 
int \mbox{\hyperlink{namespacesorting_aac8f44b28b4aa96444383030b28f8b34}{partition}} (std\+::vector$<$ int $>$ \&arr, int start, int end)
\begin{DoxyCompactList}\small\item\em The partition function sorts the array from start to end and uses the last element as the pivot. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacesorting_a263595fd9a0163b5b997b89fab3a0dc5}{iterative\+Quick\+Sort}} (std\+::vector$<$ int $>$ \&arr)
\begin{DoxyCompactList}\small\item\em The main sorting function. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacesorting_ae3a775d99dbbb94c130a973df0cfddcf}{recursive\+\_\+bubble\+\_\+sort}} (std\+::vector$<$ T $>$ \texorpdfstring{$\ast$}{*}nums, uint64\+\_\+t n)
\begin{DoxyCompactList}\small\item\em This is an implementation of the recursive\+\_\+bubble\+\_\+sort. A vector is passed to the function which is then dereferenced, so that the changes are reflected in the original vector. It also accepts a second parameter of type {\ttfamily int} and name {\ttfamily n}, which is the size of the array. \end{DoxyCompactList}\item 
std\+::vector$<$ uint64\+\_\+t $>$ \mbox{\hyperlink{namespacesorting_a06af4f0dae2de2a2ae5b797d7aa26755}{selection\+Sort}} (const std\+::vector$<$ uint64\+\_\+t $>$ \&arr, uint64\+\_\+t len)
\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacesorting_a5669396c6a6b1e14b97589b6e37980aa}{shell\+\_\+sort}} (T \texorpdfstring{$\ast$}{*}arr, size\+\_\+t LEN)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\void \mbox{\hyperlink{namespacesorting_a4d76603c54d3dc56146e92d10a043924}{shell\+\_\+sort}} (T(\&arr)\mbox{[}N\mbox{]})
\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespacesorting_af2c5b92cbfe73f63f6074c61b0a45331}{shell\+\_\+sort}} (std\+::vector$<$ T $>$ \texorpdfstring{$\ast$}{*}arr)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
for working with vectors 

for io operations

for std\+::is\+\_\+sorted

for returning multiple values form a function at once

Sorting Algorithms.

for using std\+::vector

for std\+::vector

Sorting algorithms.

for algorithm functions for assert for IO operations

Sorting algorithms

for assert for typedef datatype uint64\+\_\+t for IO operations

Sorting algorithms

for std\+::is\+\_\+sorted, std\+::swap for assert for io operations

Sorting algorithms

for std\+::is\+\_\+sorted for assert for std\+::swap and io operations

@breif Sorting algorithms

Sorting algorithms

for std\+::is\+\_\+sorted for assert function in testing for std\+::cout and std\+::endl

Contains sorting algorithms

for std\+::is\+\_\+sorted for std\+::assert for std\+::time for IO operations

Sorting algorithms

for std\+::cout for std\+::vector for std\+::stack for std\+::is\+\_\+sorted for assert

header files for collection of functions for a macro called assert which can be used to verify assumptions for io operations

Sorting algorithms

for std\+::is\+\_\+sorted(), std\+::swap() for std\+::array for assert for initializing random number generator for IO operations

Sorting algorithms

for assert for IO operations for std\+::vector for std\+::array

Sorting algorithms

for std\+::is\+\_\+sorted for std\+::assert for IO operations

for std\+::is\+\_\+sorted for assert for std\+::swap and io operations

Sorting algorithms

for std\+::is\+\_\+sorted, std\+::swap for assert for IO operations

Sorting algorithms 

\doxysubsection{Function Documentation}
\Hypertarget{namespacesorting_a034d8b276518a902962e87d3158b64fd}\index{sorting@{sorting}!binary\_search@{binary\_search}}
\index{binary\_search@{binary\_search}!sorting@{sorting}}
\doxysubsubsection{\texorpdfstring{binary\_search()}{binary\_search()}}
{\footnotesize\ttfamily \label{namespacesorting_a034d8b276518a902962e87d3158b64fd} 
template$<$class T $>$ \\
int64\+\_\+t sorting\+::binary\+\_\+search (\begin{DoxyParamCaption}\item[{std\+::vector$<$ T $>$ \&}]{arr}{, }\item[{T}]{val}{, }\item[{int64\+\_\+t}]{low}{, }\item[{int64\+\_\+t}]{high}{}\end{DoxyParamCaption})}



Binary search function to find the most suitable pace for an element. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & The generic data type. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em arr} & The actual vector in which we are searching a suitable place for the element.\\
\hline
{\em val} & The value for which suitable place is to be found. \\
\hline
{\em low} & The lower bound of the range we are searching in. \\
\hline
{\em high} & The upper bound of the range we are searching in. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the index of most suitable position of val. 
\end{DoxyReturn}

\begin{DoxyCode}{0}
\DoxyCodeLine{00063\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00064\ \ \ \ \ \textcolor{keywordflow}{if}\ (high\ <=\ low)\ \{}
\DoxyCodeLine{00065\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ (val\ >\ arr[low])\ ?\ (low\ +\ 1)\ :\ low;}
\DoxyCodeLine{00066\ \ \ \ \ \}}
\DoxyCodeLine{00067\ \ \ \ \ int64\_t\ mid\ =\ low\ +\ (high\ -\/\ low)\ /\ 2;}
\DoxyCodeLine{00068\ \ \ \ \ \textcolor{keywordflow}{if}\ (arr[mid]\ >\ val)\ \{}
\DoxyCodeLine{00069\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ binary\_search(arr,\ val,\ low,\ mid\ -\/\ 1);}
\DoxyCodeLine{00070\ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (arr[mid]\ <\ val)\ \{}
\DoxyCodeLine{00071\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \mbox{\hyperlink{namespacesorting_a034d8b276518a902962e87d3158b64fd}{binary\_search}}(arr,\ val,\ mid\ +\ 1,\ high);}
\DoxyCodeLine{00072\ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{00073\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ mid\ +\ 1;}
\DoxyCodeLine{00074\ \ \ \ \ \}}
\DoxyCodeLine{00075\ \}}

\end{DoxyCode}
\Hypertarget{namespacesorting_aa3677f87b5b4756bc77e9e34c5f27935}\index{sorting@{sorting}!gnomeSort@{gnomeSort}}
\index{gnomeSort@{gnomeSort}!sorting@{sorting}}
\doxysubsubsection{\texorpdfstring{gnomeSort()}{gnomeSort()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{namespacesorting_aa3677f87b5b4756bc77e9e34c5f27935} 
template$<$typename T , size\+\_\+t size$>$ \\
std\+::array$<$ T, size $>$ sorting\+::gnome\+Sort (\begin{DoxyParamCaption}\item[{std\+::array$<$ T, size $>$}]{arr}{}\end{DoxyParamCaption})}

This implementation is for a C++-\/style array input. The function argument is a pass-\/by-\/value and hence a copy of the array gets created which is then modified by the function and returned. 
\begin{DoxyTemplParams}{Template Parameters}
{\em T} & type of data variables in the array \\
\hline
{\em size} & size of the array \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em arr} & our array of elements. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
array with elements sorted 
\end{DoxyReturn}

\begin{DoxyCode}{0}
\DoxyCodeLine{00062\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00063\ \ \ \ \ \textcolor{comment}{//\ few\ easy\ cases}}
\DoxyCodeLine{00064\ \ \ \ \ \textcolor{keywordflow}{if}\ (size\ <=\ 1)\ \{}
\DoxyCodeLine{00065\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ arr;}
\DoxyCodeLine{00066\ \ \ \ \ \}}
\DoxyCodeLine{00067\ }
\DoxyCodeLine{00068\ \ \ \ \ \textcolor{keywordtype}{int}\ index\ =\ 0;\ \ \textcolor{comment}{//\ initialize\ loop\ index}}
\DoxyCodeLine{00069\ \ \ \ \ \textcolor{keywordflow}{while}\ (index\ <\ size)\ \{}
\DoxyCodeLine{00070\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ check\ for\ swap}}
\DoxyCodeLine{00071\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ ((index\ ==\ 0)\ ||\ (arr[index]\ >=\ arr[index\ -\/\ 1]))\ \{}
\DoxyCodeLine{00072\ \ \ \ \ \ \ \ \ \ \ \ \ index++;}
\DoxyCodeLine{00073\ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{00074\ \ \ \ \ \ \ \ \ \ \ \ \ std::swap(arr[index],\ arr[index\ -\/\ 1]);\ \ \textcolor{comment}{//\ swap}}
\DoxyCodeLine{00075\ \ \ \ \ \ \ \ \ \ \ \ \ index-\/-\/;}
\DoxyCodeLine{00076\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00077\ \ \ \ \ \}}
\DoxyCodeLine{00078\ \ \ \ \ \textcolor{keywordflow}{return}\ arr;}
\DoxyCodeLine{00079\ \}}

\end{DoxyCode}
\Hypertarget{namespacesorting_a2f8bc626eb57acae24a94636a23af6a1}\index{sorting@{sorting}!gnomeSort@{gnomeSort}}
\index{gnomeSort@{gnomeSort}!sorting@{sorting}}
\doxysubsubsection{\texorpdfstring{gnomeSort()}{gnomeSort()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{namespacesorting_a2f8bc626eb57acae24a94636a23af6a1} 
template$<$typename T $>$ \\
void sorting\+::gnome\+Sort (\begin{DoxyParamCaption}\item[{T \texorpdfstring{$\ast$}{*}}]{arr}{, }\item[{int}]{size}{}\end{DoxyParamCaption})}

This implementation is for a C-\/style array input that gets modified in place. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em arr} & our array of elements. \\
\hline
 & {\em size} & size of given array \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{00034\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00035\ \ \ \ \ \textcolor{comment}{//\ few\ easy\ cases}}
\DoxyCodeLine{00036\ \ \ \ \ \textcolor{keywordflow}{if}\ (size\ <=\ 1)\ \{}
\DoxyCodeLine{00037\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return};}
\DoxyCodeLine{00038\ \ \ \ \ \}}
\DoxyCodeLine{00039\ }
\DoxyCodeLine{00040\ \ \ \ \ \textcolor{keywordtype}{int}\ index\ =\ 0;\ \ \textcolor{comment}{//\ initialize\ some\ variables.}}
\DoxyCodeLine{00041\ \ \ \ \ \textcolor{keywordflow}{while}\ (index\ <\ size)\ \{}
\DoxyCodeLine{00042\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ check\ for\ swap}}
\DoxyCodeLine{00043\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ ((index\ ==\ 0)\ ||\ (arr[index]\ >=\ arr[index\ -\/\ 1]))\ \{}
\DoxyCodeLine{00044\ \ \ \ \ \ \ \ \ \ \ \ \ index++;}
\DoxyCodeLine{00045\ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{00046\ \ \ \ \ \ \ \ \ \ \ \ \ std::swap(arr[index],\ arr[index\ -\/\ 1]);\ \ \textcolor{comment}{//\ swap}}
\DoxyCodeLine{00047\ \ \ \ \ \ \ \ \ \ \ \ \ index-\/-\/;}
\DoxyCodeLine{00048\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00049\ \ \ \ \ \}}
\DoxyCodeLine{00050\ \}}

\end{DoxyCode}
\Hypertarget{namespacesorting_a8fe6bac9e03f58abcc2ce26ef3de1b5f}\index{sorting@{sorting}!insertionSort@{insertionSort}}
\index{insertionSort@{insertionSort}!sorting@{sorting}}
\doxysubsubsection{\texorpdfstring{insertionSort()}{insertionSort()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{namespacesorting_a8fe6bac9e03f58abcc2ce26ef3de1b5f} 
template$<$typename T $>$ \\
void sorting\+::insertion\+Sort (\begin{DoxyParamCaption}\item[{std\+::vector$<$ T $>$ \texorpdfstring{$\ast$}{*}}]{arr}{}\end{DoxyParamCaption})}



Insertion Sort for a vector. 

Insertion Sort Function


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & type of array \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em arr} & pointer to array to be sorted\\
\hline
\end{DoxyParams}

\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Type of the vector elements \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em arr} & Pointer to the vector to be sorted \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{00077\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00078\ \ \ \ \ \textcolor{keywordtype}{size\_t}\ n\ =\ arr-\/>size();}
\DoxyCodeLine{00079\ }
\DoxyCodeLine{00080\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 1;\ i\ <\ n;\ i++)\ \{}
\DoxyCodeLine{00081\ \ \ \ \ \ \ \ \ T\ temp\ =\ arr[0][i];}
\DoxyCodeLine{00082\ \ \ \ \ \ \ \ \ int32\_t\ j\ =\ i\ -\/\ 1;}
\DoxyCodeLine{00083\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (j\ >=\ 0\ \&\&\ temp\ <\ arr[0][j])\ \{}
\DoxyCodeLine{00084\ \ \ \ \ \ \ \ \ \ \ \ \ arr[0][j\ +\ 1]\ =\ arr[0][j];}
\DoxyCodeLine{00085\ \ \ \ \ \ \ \ \ \ \ \ \ j-\/-\/;}
\DoxyCodeLine{00086\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00087\ \ \ \ \ \ \ \ \ arr[0][j\ +\ 1]\ =\ temp;}
\DoxyCodeLine{00088\ \ \ \ \ \}}
\DoxyCodeLine{00089\ \}}

\end{DoxyCode}
\Hypertarget{namespacesorting_a78cb2f3b97b6db2c062b2a1df05c9ea9}\index{sorting@{sorting}!insertionSort@{insertionSort}}
\index{insertionSort@{insertionSort}!sorting@{sorting}}
\doxysubsubsection{\texorpdfstring{insertionSort()}{insertionSort()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{namespacesorting_a78cb2f3b97b6db2c062b2a1df05c9ea9} 
template$<$typename T $>$ \\
void sorting\+::insertion\+Sort (\begin{DoxyParamCaption}\item[{T \texorpdfstring{$\ast$}{*}}]{arr}{, }\item[{int}]{n}{}\end{DoxyParamCaption})}



Insertion Sort Function. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & type of array \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em arr} & Array to be sorted \\
\hline
 & {\em n} & Size of Array\\
\hline
\end{DoxyParams}

\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Type of the array elements \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em arr} & Array to be sorted \\
\hline
 & {\em n} & Size of the array \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{00059\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00060\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{int}\ i\ =\ 1;\ i\ <\ n;\ i++)\ \{}
\DoxyCodeLine{00061\ \ \ \ \ \ \ \ \ T\ temp\ =\ arr[i];}
\DoxyCodeLine{00062\ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{int}\ j\ =\ i\ -\/\ 1;}
\DoxyCodeLine{00063\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (j\ >=\ 0\ \&\&\ temp\ <\ arr[j])\ \{}
\DoxyCodeLine{00064\ \ \ \ \ \ \ \ \ \ \ \ \ arr[j\ +\ 1]\ =\ arr[j];}
\DoxyCodeLine{00065\ \ \ \ \ \ \ \ \ \ \ \ \ j-\/-\/;}
\DoxyCodeLine{00066\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00067\ \ \ \ \ \ \ \ \ arr[j\ +\ 1]\ =\ temp;}
\DoxyCodeLine{00068\ \ \ \ \ \}}
\DoxyCodeLine{00069\ \}}

\end{DoxyCode}
\Hypertarget{namespacesorting_a5f4bc75cca6dd8294af2d0e328006c68}\index{sorting@{sorting}!insertionSort\_binsrch@{insertionSort\_binsrch}}
\index{insertionSort\_binsrch@{insertionSort\_binsrch}!sorting@{sorting}}
\doxysubsubsection{\texorpdfstring{insertionSort\_binsrch()}{insertionSort\_binsrch()}}
{\footnotesize\ttfamily \label{namespacesorting_a5f4bc75cca6dd8294af2d0e328006c68} 
template$<$typename T $>$ \\
void sorting\+::insertion\+Sort\+\_\+binsrch (\begin{DoxyParamCaption}\item[{std\+::vector$<$ T $>$ \&}]{arr}{}\end{DoxyParamCaption})}



Insertion sort function to sort the vector. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & The generic data type. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em arr} & The actual vector to sort. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Void. 
\end{DoxyReturn}

\begin{DoxyCode}{0}
\DoxyCodeLine{00084\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00085\ \ \ \ \ int64\_t\ n\ =\ arr.size();}
\DoxyCodeLine{00086\ }
\DoxyCodeLine{00087\ \ \ \ \ \textcolor{keywordflow}{for}\ (int64\_t\ i\ =\ 1;\ i\ <\ n;\ i++)\ \{}
\DoxyCodeLine{00088\ \ \ \ \ \ \ \ \ T\ key\ =\ arr[i];}
\DoxyCodeLine{00089\ \ \ \ \ \ \ \ \ int64\_t\ j\ =\ i\ -\/\ 1;}
\DoxyCodeLine{00090\ \ \ \ \ \ \ \ \ int64\_t\ loc\ =\ \mbox{\hyperlink{namespacesorting_a034d8b276518a902962e87d3158b64fd}{sorting::binary\_search}}(arr,\ key,\ 0,\ j);}
\DoxyCodeLine{00091\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (j\ >=\ loc)\ \{}
\DoxyCodeLine{00092\ \ \ \ \ \ \ \ \ \ \ \ \ arr[j\ +\ 1]\ =\ arr[j];}
\DoxyCodeLine{00093\ \ \ \ \ \ \ \ \ \ \ \ \ j-\/-\/;}
\DoxyCodeLine{00094\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00095\ \ \ \ \ \ \ \ \ arr[j\ +\ 1]\ =\ key;}
\DoxyCodeLine{00096\ \ \ \ \ \}}
\DoxyCodeLine{00097\ \}}

\end{DoxyCode}
\Hypertarget{namespacesorting_a263595fd9a0163b5b997b89fab3a0dc5}\index{sorting@{sorting}!iterativeQuickSort@{iterativeQuickSort}}
\index{iterativeQuickSort@{iterativeQuickSort}!sorting@{sorting}}
\doxysubsubsection{\texorpdfstring{iterativeQuickSort()}{iterativeQuickSort()}}
{\footnotesize\ttfamily \label{namespacesorting_a263595fd9a0163b5b997b89fab3a0dc5} 
void sorting\+::iterative\+Quick\+Sort (\begin{DoxyParamCaption}\item[{std\+::vector$<$ int $>$ \&}]{arr}{}\end{DoxyParamCaption})}



The main sorting function. 

The iterative quick sort uses the stack instead of recursion for saving and restoring the environment between calls. It does not need the end and start params, because it is not recursive. 
\begin{DoxyParams}{Parameters}
{\em arr} & array to be sorted \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void 
\end{DoxyReturn}

\begin{DoxyCode}{0}
\DoxyCodeLine{00059\ \{}
\DoxyCodeLine{00060\ \ \ \ \ std::stack<int>\ \mbox{\hyperlink{paranthesis__matching_8cpp_aa37d24a036d239b3b528f13b9de880c7}{stack}};}
\DoxyCodeLine{00061\ \ \ \ \ \textcolor{keywordtype}{int}\ start\ =\ 0;}
\DoxyCodeLine{00062\ \ \ \ \ \textcolor{keywordtype}{int}\ end\ =\ arr.size()-\/1;}
\DoxyCodeLine{00063\ \ \ \ \ \mbox{\hyperlink{classstack}{stack}}.\mbox{\hyperlink{classstack_a90df277532c23519aa7ac3c08ed90a1d}{push}}(start);}
\DoxyCodeLine{00064\ \ \ \ \ \mbox{\hyperlink{classstack}{stack}}.\mbox{\hyperlink{classstack_a90df277532c23519aa7ac3c08ed90a1d}{push}}(end);}
\DoxyCodeLine{00065\ }
\DoxyCodeLine{00066\ \ \ \ \ \textcolor{keywordflow}{while}(!\mbox{\hyperlink{classstack}{stack}}.empty())}
\DoxyCodeLine{00067\ \ \ \ \ \{}
\DoxyCodeLine{00068\ \ \ \ \ \ \ \ \ end\ =\ \mbox{\hyperlink{classstack}{stack}}.\mbox{\hyperlink{classstack_ae09630c4384903d187801921b2ddc709}{top}}();}
\DoxyCodeLine{00069\ \ \ \ \ \ \ \ \ \mbox{\hyperlink{classstack}{stack}}.\mbox{\hyperlink{classstack_a3647fb4418890f19e0dc414b8092b8b0}{pop}}();}
\DoxyCodeLine{00070\ \ \ \ \ \ \ \ \ start\ =\ \mbox{\hyperlink{classstack}{stack}}.\mbox{\hyperlink{classstack_ae09630c4384903d187801921b2ddc709}{top}}();}
\DoxyCodeLine{00071\ \ \ \ \ \ \ \ \ \mbox{\hyperlink{classstack}{stack}}.\mbox{\hyperlink{classstack_a3647fb4418890f19e0dc414b8092b8b0}{pop}}();}
\DoxyCodeLine{00072\ }
\DoxyCodeLine{00073\ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{int}\ pivotIndex\ =\ partition(arr,start,end);}
\DoxyCodeLine{00074\ }
\DoxyCodeLine{00075\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}(pivotIndex\ -\/1\ >\ start)}
\DoxyCodeLine{00076\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00077\ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{classstack}{stack}}.\mbox{\hyperlink{classstack_a90df277532c23519aa7ac3c08ed90a1d}{push}}(start);}
\DoxyCodeLine{00078\ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{classstack}{stack}}.\mbox{\hyperlink{classstack_a90df277532c23519aa7ac3c08ed90a1d}{push}}(pivotIndex-\/1);}
\DoxyCodeLine{00079\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00080\ }
\DoxyCodeLine{00081\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}(pivotIndex+1<end)}
\DoxyCodeLine{00082\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00083\ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{classstack}{stack}}.\mbox{\hyperlink{classstack_a90df277532c23519aa7ac3c08ed90a1d}{push}}(pivotIndex+1);}
\DoxyCodeLine{00084\ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{classstack}{stack}}.\mbox{\hyperlink{classstack_a90df277532c23519aa7ac3c08ed90a1d}{push}}(end);}
\DoxyCodeLine{00085\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00086\ \ \ \ \ \}}
\DoxyCodeLine{00087\ \}}

\end{DoxyCode}
\Hypertarget{namespacesorting_aa26de383227859210f14dcf12201a079}\index{sorting@{sorting}!merge@{merge}}
\index{merge@{merge}!sorting@{sorting}}
\doxysubsubsection{\texorpdfstring{merge()}{merge()}}
{\footnotesize\ttfamily \label{namespacesorting_aa26de383227859210f14dcf12201a079} 
template$<$class Iterator $>$ \\
void sorting\+::merge (\begin{DoxyParamCaption}\item[{Iterator}]{l}{, }\item[{Iterator}]{r}{, }\item[{const Iterator}]{e}{, }\item[{char}]{b}{\mbox{[}$\,$\mbox{]}}\end{DoxyParamCaption})}



merges 2 sorted adjacent segments into a larger sorted segment 

best-\/case = worst-\/case = O(n) 
\begin{DoxyParams}{Parameters}
{\em l} & points to the left part \\
\hline
{\em r} & points to the right part, end of left part \\
\hline
{\em e} & points to end of right part \\
\hline
{\em b} & points at the buffer \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{00057\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00058\ \ \ \ \ \textcolor{comment}{//\ create\ 2\ pointers\ to\ point\ at\ the\ buffer}}
\DoxyCodeLine{00059\ \ \ \ \ \textcolor{keyword}{auto}\ p(\textcolor{keyword}{reinterpret\_cast<}std::remove\_reference\_t<decltype(*l)\textcolor{keyword}{>}*>(b)),\ c(p);}
\DoxyCodeLine{00060\ \ \ \ \ \textcolor{comment}{//\ move\ the\ left\ part\ of\ the\ segment}}
\DoxyCodeLine{00061\ \ \ \ \ \textcolor{keywordflow}{for}\ (Iterator\ t(l);\ r\ !=\ t;\ ++t)\ *p++\ =\ std::move(*t);}
\DoxyCodeLine{00062\ \ \ \ \ \textcolor{comment}{//\ while\ neither\ the\ buffer\ nor\ the\ right\ part\ has\ been\ exhausted}}
\DoxyCodeLine{00063\ \ \ \ \ \textcolor{comment}{//\ move\ the\ smallest\ element\ of\ the\ two\ back\ to\ the\ container}}
\DoxyCodeLine{00064\ \ \ \ \ \textcolor{keywordflow}{while}\ (e\ !=\ r\ \&\&\ c\ !=\ p)\ *l++\ =\ std::move(*r\ <\ *c\ ?\ *r++\ :\ *c++);}
\DoxyCodeLine{00065\ \ \ \ \ \textcolor{comment}{//\ notice\ only\ one\ of\ the\ two\ following\ loops\ will\ be\ executed}}
\DoxyCodeLine{00066\ \ \ \ \ \textcolor{comment}{//\ while\ the\ right\ part\ hasn't\ bee\ exhausted,\ move\ it\ back}}
\DoxyCodeLine{00067\ \ \ \ \ \textcolor{keywordflow}{while}\ (e\ !=\ r)\ *l++\ =\ std::move(*r++);}
\DoxyCodeLine{00068\ \ \ \ \ \textcolor{comment}{//\ while\ the\ buffer\ hasn't\ bee\ exhausted,\ move\ it\ back}}
\DoxyCodeLine{00069\ \ \ \ \ \textcolor{keywordflow}{while}\ (c\ !=\ p)\ *l++\ =\ std::move(*c++);}
\DoxyCodeLine{00070\ \}}

\end{DoxyCode}
\Hypertarget{namespacesorting_ae97f4dd815654c4682f564afd718e824}\index{sorting@{sorting}!non\_recursive\_merge\_sort@{non\_recursive\_merge\_sort}}
\index{non\_recursive\_merge\_sort@{non\_recursive\_merge\_sort}!sorting@{sorting}}
\doxysubsubsection{\texorpdfstring{non\_recursive\_merge\_sort()}{non\_recursive\_merge\_sort()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily \label{namespacesorting_ae97f4dd815654c4682f564afd718e824} 
template$<$class Iterator $>$ \\
void sorting\+::non\+\_\+recursive\+\_\+merge\+\_\+sort (\begin{DoxyParamCaption}\item[{const Iterator}]{first}{, }\item[{const Iterator}]{last}{}\end{DoxyParamCaption})}



bottom-\/up merge sort which sorts elements in a non-\/decreasing order 


\begin{DoxyParams}{Parameters}
{\em first} & points to the first element \\
\hline
{\em last} & points to 1-\/step past the last element \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{00086\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00087\ \ \ \ \ non\_recursive\_merge\_sort(first,\ last,\ last\ -\/\ first);}
\DoxyCodeLine{00088\ \}}

\end{DoxyCode}
\Hypertarget{namespacesorting_a140d913e42fb94176a0b2c8b29a80420}\index{sorting@{sorting}!non\_recursive\_merge\_sort@{non\_recursive\_merge\_sort}}
\index{non\_recursive\_merge\_sort@{non\_recursive\_merge\_sort}!sorting@{sorting}}
\doxysubsubsection{\texorpdfstring{non\_recursive\_merge\_sort()}{non\_recursive\_merge\_sort()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily \label{namespacesorting_a140d913e42fb94176a0b2c8b29a80420} 
template$<$class Iterator $>$ \\
void sorting\+::non\+\_\+recursive\+\_\+merge\+\_\+sort (\begin{DoxyParamCaption}\item[{const Iterator}]{first}{, }\item[{const Iterator}]{last}{, }\item[{const size\+\_\+t}]{n}{}\end{DoxyParamCaption})}



bottom-\/up merge sort which sorts elements in a non-\/decreasing order 

sorts elements non-\/recursively by breaking them into small segments, merging adjacent segments into larger sorted segments, then increasing the sizes of segments by factors of 2 and repeating the same process. best-\/case = worst-\/case = O(n log(n)) 
\begin{DoxyParams}{Parameters}
{\em first} & points to the first element \\
\hline
{\em last} & points to 1-\/step past the last element \\
\hline
{\em n} & the number of elements \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{00026\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00027\ \ \ \ \ \textcolor{comment}{//\ create\ a\ buffer\ large\ enough\ to\ store\ all\ elements}}
\DoxyCodeLine{00028\ \ \ \ \ \textcolor{comment}{//\ dynamically\ allocated\ to\ comply\ with\ cpplint}}
\DoxyCodeLine{00029\ \ \ \ \ \textcolor{keywordtype}{char}*\ buffer\ =\ \textcolor{keyword}{new}\ \textcolor{keywordtype}{char}[n\ *\ \textcolor{keyword}{sizeof}(*first)];}
\DoxyCodeLine{00030\ \ \ \ \ \textcolor{comment}{//\ buffer\ size\ can\ be\ optimized\ to\ largest\ power\ of\ 2\ less\ than\ n}}
\DoxyCodeLine{00031\ \ \ \ \ \textcolor{comment}{//\ elements\ divide\ the\ container\ into\ equally-\/sized\ segments\ whose}}
\DoxyCodeLine{00032\ \ \ \ \ \textcolor{comment}{//\ length\ start\ at\ 1\ and\ keeps\ increasing\ by\ factors\ of\ 2}}
\DoxyCodeLine{00033\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ length(1);\ length\ <\ n;\ length\ <<=\ 1)\ \{}
\DoxyCodeLine{00034\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ merge\ adjacent\ segments\ whose\ number\ is\ n\ /\ (length\ *\ 2)}}
\DoxyCodeLine{00035\ \ \ \ \ \ \ \ \ Iterator\ left(first);}
\DoxyCodeLine{00036\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ counter(n\ /\ (length\ <<\ 1));\ counter;\ -\/-\/counter)\ \{}
\DoxyCodeLine{00037\ \ \ \ \ \ \ \ \ \ \ \ \ Iterator\ right(left\ +\ length),\ end(right\ +\ length);}
\DoxyCodeLine{00038\ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{group__sorting_ga460c61cd948203b4816bef2accb3fc73}{merge}}(left,\ right,\ end,\ buffer);}
\DoxyCodeLine{00039\ \ \ \ \ \ \ \ \ \ \ \ \ left\ =\ end;}
\DoxyCodeLine{00040\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00041\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ if\ the\ number\ of\ remaining\ elements\ (n\ *\ 2\ \%\ length)\ is\ longer}}
\DoxyCodeLine{00042\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ than\ a\ segment,\ merge\ the\ remaining\ elements}}
\DoxyCodeLine{00043\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ ((n\ \&\ ((length\ <<\ 1)\ -\/\ 1))\ >\ length)}
\DoxyCodeLine{00044\ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{group__sorting_ga460c61cd948203b4816bef2accb3fc73}{merge}}(left,\ left\ +\ length,\ last,\ buffer);}
\DoxyCodeLine{00045\ \ \ \ \ \}}
\DoxyCodeLine{00046\ \ \ \ \ \textcolor{keyword}{delete}[]\ buffer;}
\DoxyCodeLine{00047\ \}}

\end{DoxyCode}
\Hypertarget{namespacesorting_a27236b8d3df3832e1f1225576a122534}\index{sorting@{sorting}!non\_recursive\_merge\_sort@{non\_recursive\_merge\_sort}}
\index{non\_recursive\_merge\_sort@{non\_recursive\_merge\_sort}!sorting@{sorting}}
\doxysubsubsection{\texorpdfstring{non\_recursive\_merge\_sort()}{non\_recursive\_merge\_sort()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily \label{namespacesorting_a27236b8d3df3832e1f1225576a122534} 
template$<$class Iterator $>$ \\
void sorting\+::non\+\_\+recursive\+\_\+merge\+\_\+sort (\begin{DoxyParamCaption}\item[{const Iterator}]{first}{, }\item[{const size\+\_\+t}]{n}{}\end{DoxyParamCaption})}



bottom-\/up merge sort which sorts elements in a non-\/decreasing order 


\begin{DoxyParams}{Parameters}
{\em first} & points to the first element \\
\hline
{\em n} & the number of elements \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{00077\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00078\ \ \ \ \ non\_recursive\_merge\_sort(first,\ first\ +\ n,\ n);}
\DoxyCodeLine{00079\ \}}

\end{DoxyCode}
\Hypertarget{namespacesorting_aac8f44b28b4aa96444383030b28f8b34}\index{sorting@{sorting}!partition@{partition}}
\index{partition@{partition}!sorting@{sorting}}
\doxysubsubsection{\texorpdfstring{partition()}{partition()}}
{\footnotesize\ttfamily \label{namespacesorting_aac8f44b28b4aa96444383030b28f8b34} 
int sorting\+::partition (\begin{DoxyParamCaption}\item[{std\+::vector$<$ int $>$ \&}]{arr}{, }\item[{int}]{start}{, }\item[{int}]{end}{}\end{DoxyParamCaption})}



The partition function sorts the array from start to end and uses the last element as the pivot. 


\begin{DoxyParams}{Parameters}
{\em arr} & the array to be sorted \\
\hline
{\em start} & starting index \\
\hline
{\em end} & ending index \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
int next index of the pivot 
\end{DoxyReturn}

\begin{DoxyCode}{0}
\DoxyCodeLine{00034\ \{}
\DoxyCodeLine{00035\ \ \ \ \ \textcolor{keywordtype}{int}\ pivot\ =\ arr[end];}
\DoxyCodeLine{00036\ \ \ \ \ \textcolor{keywordtype}{int}\ index\ =\ start\ -\/\ 1;}
\DoxyCodeLine{00037\ }
\DoxyCodeLine{00038\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{int}\ j\ =\ start;\ j\ <\ end;\ j++)\ \{}
\DoxyCodeLine{00039\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (arr[j]\ <=\ pivot)\ \{}
\DoxyCodeLine{00040\ \ \ \ \ \ \ \ \ \ \ \ \ std::swap(arr[++index],\ arr[j]);}
\DoxyCodeLine{00041\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00042\ \ \ \ \ \}}
\DoxyCodeLine{00043\ }
\DoxyCodeLine{00044\ \ \ \ \ std::swap(arr[index\ +\ 1],\ arr[end]);}
\DoxyCodeLine{00045\ \ \ \ \ \textcolor{keywordflow}{return}\ index\ +\ 1;}
\DoxyCodeLine{00046\ \}}

\end{DoxyCode}
\Hypertarget{namespacesorting_a0e9e1b21a1684585e9e50f9afe4d53a3}\index{sorting@{sorting}!pigeonSort@{pigeonSort}}
\index{pigeonSort@{pigeonSort}!sorting@{sorting}}
\doxysubsubsection{\texorpdfstring{pigeonSort()}{pigeonSort()}}
{\footnotesize\ttfamily \label{namespacesorting_a0e9e1b21a1684585e9e50f9afe4d53a3} 
template$<$std\+::size\+\_\+t N$>$ \\
std\+::array$<$ int, N $>$ sorting\+::pigeon\+Sort (\begin{DoxyParamCaption}\item[{std\+::array$<$ int, N $>$}]{arr}{}\end{DoxyParamCaption})}

Pigeonhole sorting of array of size n The function will sort the array through Pigeonhole algorithm and print 
\begin{DoxyParams}{Parameters}
{\em arr} & unsorted array of elements \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
sorted array of elements 
\end{DoxyReturn}

\begin{DoxyCode}{0}
\DoxyCodeLine{00034\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00035\ \ \ \ \ \textcolor{comment}{//\ Finding\ min\ and\ max*}}
\DoxyCodeLine{00036\ \ \ \ \ \textcolor{keyword}{auto}\ min\ =\ std::min\_element(std::begin(arr),\ std::end(arr));}
\DoxyCodeLine{00037\ \ \ \ \ \textcolor{keyword}{auto}\ max\ =\ std::max\_element(std::begin(arr),\ std::end(arr));}
\DoxyCodeLine{00038\ }
\DoxyCodeLine{00039\ \ \ \ \ \textcolor{comment}{//\ Range\ refers\ to\ the\ number\ of\ holes\ required}}
\DoxyCodeLine{00040\ \ \ \ \ \textcolor{keywordtype}{int}\ range\ =\ *max\ -\/\ *min\ +\ 1;}
\DoxyCodeLine{00041\ \ \ \ \ \textcolor{keywordtype}{int}\ *hole\ =\ \textcolor{keyword}{new}\ \textcolor{keywordtype}{int}[range]();}
\DoxyCodeLine{00042\ }
\DoxyCodeLine{00043\ \ \ \ \ \textcolor{comment}{//\ Copying\ all\ array\ values\ to\ pigeonhole}}
\DoxyCodeLine{00044\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{int}\ i\ =\ 0;\ i\ <\ N;\ i++)\ \{}
\DoxyCodeLine{00045\ \ \ \ \ \ \ \ \ hole[arr[i]\ -\/\ *min]\ =\ arr[i];}
\DoxyCodeLine{00046\ \ \ \ \ \}}
\DoxyCodeLine{00047\ }
\DoxyCodeLine{00048\ \ \ \ \ \textcolor{comment}{//\ Deleting\ elements\ from\ list\ and\ storing\ to\ original\ array}}
\DoxyCodeLine{00049\ \ \ \ \ \textcolor{keywordtype}{int}\ count\ =\ 0;}
\DoxyCodeLine{00050\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{int}\ i\ =\ 0;\ i\ <\ range;\ i++)\ \{}
\DoxyCodeLine{00051\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (hole[i]\ !=\ \textcolor{charliteral}{'\(\backslash\)0'})\ \{}
\DoxyCodeLine{00052\ \ \ \ \ \ \ \ \ \ \ \ \ arr[count]\ =\ hole[i];}
\DoxyCodeLine{00053\ \ \ \ \ \ \ \ \ \ \ \ \ hole[i]\ =\ \{\};}
\DoxyCodeLine{00054\ \ \ \ \ \ \ \ \ \ \ \ \ count++;}
\DoxyCodeLine{00055\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00056\ \ \ \ \ \}}
\DoxyCodeLine{00057\ \ \ \ \ \textcolor{keyword}{delete}[]\ hole;}
\DoxyCodeLine{00058\ }
\DoxyCodeLine{00059\ \ \ \ \ \textcolor{keywordflow}{return}\ arr;}
\DoxyCodeLine{00060\ \}}

\end{DoxyCode}
\Hypertarget{namespacesorting_a9f59fe72dacc1f1218ef3c303d843168}\index{sorting@{sorting}!quicksort@{quicksort}}
\index{quicksort@{quicksort}!sorting@{sorting}}
\doxysubsubsection{\texorpdfstring{quicksort()}{quicksort()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{namespacesorting_a9f59fe72dacc1f1218ef3c303d843168} 
template$<$typename T $>$ \\
void sorting\+::quicksort (\begin{DoxyParamCaption}\item[{std\+::vector$<$ T $>$ \texorpdfstring{$\ast$}{*}}]{arr}{, }\item[{int32\+\_\+t}]{low}{, }\item[{int32\+\_\+t}]{high}{}\end{DoxyParamCaption})}

3-\/way partition based quick sort. This function accepts array pointer and modified the input array. 
\begin{DoxyTemplParams}{Template Parameters}
{\em T} & type of data in the vector array \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em arr} & vector array to sort \\
\hline
\mbox{\texttt{ in}}  & {\em low} & lower limit of window to partition \\
\hline
\mbox{\texttt{ in}}  & {\em high} & upper limit of window to partition \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{00094\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00095\ \ \ \ \ \textcolor{keywordflow}{if}\ (low\ >=\ high)\ \{\ \ \textcolor{comment}{//\ 1\ or\ 0\ elements}}
\DoxyCodeLine{00096\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return};}
\DoxyCodeLine{00097\ \ \ \ \ \}}
\DoxyCodeLine{00098\ }
\DoxyCodeLine{00099\ \ \ \ \ int32\_t\ i\ =\ 0,\ j\ =\ 0;}
\DoxyCodeLine{00100\ }
\DoxyCodeLine{00101\ \ \ \ \ \textcolor{comment}{//\ i\ and\ j\ are\ passed\ as\ reference}}
\DoxyCodeLine{00102\ \ \ \ \ partition3(arr,\ low,\ high,\ \&i,\ \&j);}
\DoxyCodeLine{00103\ }
\DoxyCodeLine{00104\ \ \ \ \ \textcolor{comment}{//\ Recur\ two\ halves}}
\DoxyCodeLine{00105\ \ \ \ \ quicksort(arr,\ low,\ i);}
\DoxyCodeLine{00106\ \ \ \ \ quicksort(arr,\ j,\ high);}
\DoxyCodeLine{00107\ \}}

\end{DoxyCode}
\Hypertarget{namespacesorting_a6eb67c2f91c98cf4464f75b5882022de}\index{sorting@{sorting}!quicksort@{quicksort}}
\index{quicksort@{quicksort}!sorting@{sorting}}
\doxysubsubsection{\texorpdfstring{quicksort()}{quicksort()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{namespacesorting_a6eb67c2f91c98cf4464f75b5882022de} 
template$<$typename T $>$ \\
std\+::vector$<$ T $>$ sorting\+::quicksort (\begin{DoxyParamCaption}\item[{std\+::vector$<$ T $>$}]{arr}{, }\item[{int32\+\_\+t}]{low}{, }\item[{int32\+\_\+t}]{high}{}\end{DoxyParamCaption})}

3-\/way partition based quick sort. This function accepts array by value and creates a copy of it. The array copy gets sorted and returned by the function. 
\begin{DoxyTemplParams}{Template Parameters}
{\em T} & type of data in the vector array \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em arr} & vector array to sort \\
\hline
\mbox{\texttt{ in}}  & {\em low} & lower limit of window to partition \\
\hline
\mbox{\texttt{ in}}  & {\em high} & upper limit of window to partition \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
sorted array vector 
\end{DoxyReturn}

\begin{DoxyCode}{0}
\DoxyCodeLine{00119\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00120\ \ \ \ \ \textcolor{keywordflow}{if}\ (low\ >=\ high)\ \{\ \ \textcolor{comment}{//\ 1\ or\ 0\ elements}}
\DoxyCodeLine{00121\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ arr;}
\DoxyCodeLine{00122\ \ \ \ \ \}}
\DoxyCodeLine{00123\ }
\DoxyCodeLine{00124\ \ \ \ \ int32\_t\ i\ =\ 0,\ j\ =\ 0;}
\DoxyCodeLine{00125\ }
\DoxyCodeLine{00126\ \ \ \ \ \textcolor{comment}{//\ i\ and\ j\ are\ passed\ as\ reference}}
\DoxyCodeLine{00127\ \ \ \ \ partition3(\&arr,\ low,\ high,\ \&i,\ \&j);}
\DoxyCodeLine{00128\ }
\DoxyCodeLine{00129\ \ \ \ \ \textcolor{comment}{//\ Recur\ two\ halves}}
\DoxyCodeLine{00130\ \ \ \ \ quicksort(\&arr,\ low,\ i);}
\DoxyCodeLine{00131\ \ \ \ \ quicksort(\&arr,\ j,\ high);}
\DoxyCodeLine{00132\ }
\DoxyCodeLine{00133\ \ \ \ \ \textcolor{keywordflow}{return}\ arr;}
\DoxyCodeLine{00134\ \}}

\end{DoxyCode}
\Hypertarget{namespacesorting_affc6ee160142cd017f8c4b213437d0fd}\index{sorting@{sorting}!randomized\_bogosort@{randomized\_bogosort}}
\index{randomized\_bogosort@{randomized\_bogosort}!sorting@{sorting}}
\doxysubsubsection{\texorpdfstring{randomized\_bogosort()}{randomized\_bogosort()}}
{\footnotesize\ttfamily \label{namespacesorting_affc6ee160142cd017f8c4b213437d0fd} 
template$<$typename T , size\+\_\+t N$>$ \\
std\+::array$<$ T, N $>$ sorting\+::randomized\+\_\+bogosort (\begin{DoxyParamCaption}\item[{std\+::array$<$ T, N $>$}]{arr}{}\end{DoxyParamCaption})}

Implement randomized Bogosort algorithm and sort the elements of a given array. 
\begin{DoxyTemplParams}{Template Parameters}
{\em T} & typename of the array \\
\hline
{\em N} & length of array \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em arr} & array to sort \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
new array with elements sorted from a given array 
\end{DoxyReturn}

\begin{DoxyCode}{0}
\DoxyCodeLine{00052\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00053\ \ \ \ \ \textcolor{comment}{//\ Untill\ array\ is\ not\ sorted}}
\DoxyCodeLine{00054\ \ \ \ \ std::random\_device\ random\_device;}
\DoxyCodeLine{00055\ \ \ \ \ std::mt19937\ generator(random\_device());}
\DoxyCodeLine{00056\ \ \ \ \ \textcolor{keywordflow}{while}\ (!std::is\_sorted(arr.begin(),\ arr.end()))\ \{}
\DoxyCodeLine{00057\ \ \ \ \ \ \ \ \ std::shuffle(arr.begin(),\ arr.end(),\ generator);\textcolor{comment}{//\ Shuffle\ the\ array}}
\DoxyCodeLine{00058\ \ \ \ \ \}}
\DoxyCodeLine{00059\ \ \ \ \ \textcolor{keywordflow}{return}\ arr;}
\DoxyCodeLine{00060\ \}}

\end{DoxyCode}
\Hypertarget{namespacesorting_ae3a775d99dbbb94c130a973df0cfddcf}\index{sorting@{sorting}!recursive\_bubble\_sort@{recursive\_bubble\_sort}}
\index{recursive\_bubble\_sort@{recursive\_bubble\_sort}!sorting@{sorting}}
\doxysubsubsection{\texorpdfstring{recursive\_bubble\_sort()}{recursive\_bubble\_sort()}}
{\footnotesize\ttfamily \label{namespacesorting_ae3a775d99dbbb94c130a973df0cfddcf} 
template$<$typename T $>$ \\
void sorting\+::recursive\+\_\+bubble\+\_\+sort (\begin{DoxyParamCaption}\item[{std\+::vector$<$ T $>$ \texorpdfstring{$\ast$}{*}}]{nums}{, }\item[{uint64\+\_\+t}]{n}{}\end{DoxyParamCaption})}



This is an implementation of the recursive\+\_\+bubble\+\_\+sort. A vector is passed to the function which is then dereferenced, so that the changes are reflected in the original vector. It also accepts a second parameter of type {\ttfamily int} and name {\ttfamily n}, which is the size of the array. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & type of data variables in the array \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em nums} & our array of elements. \\
\hline
{\em n} & size of the array \\
\hline
\end{DoxyParams}
\texorpdfstring{$<$}{<} base case; when size of the array is 1

\texorpdfstring{$<$}{<} iterating over the entire array

\texorpdfstring{$<$}{<} if a larger number appears before the smaller one, swap them.
\begin{DoxyCode}{0}
\DoxyCodeLine{00074\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00075\ \ \ \ \ \textcolor{keywordflow}{if}\ (n\ ==\ 1)\ \{\ \ \textcolor{comment}{//!<\ base\ case;\ when\ size\ of\ the\ array\ is\ 1}}
\DoxyCodeLine{00076\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return};}
\DoxyCodeLine{00077\ \ \ \ \ \}}
\DoxyCodeLine{00078\ }
\DoxyCodeLine{00079\ \ \ \ \ \textcolor{keywordflow}{for}\ (uint64\_t\ i\ =\ 0;\ i\ <\ n\ -\/\ 1;\ i++)\ \{\ \ \textcolor{comment}{//!<\ iterating\ over\ the\ entire\ array}\textcolor{comment}{}}
\DoxyCodeLine{00080\ \textcolor{comment}{\ \ \ \ \ \ \ \ //!<\ if\ a\ larger\ number\ appears\ before\ the\ smaller\ one,\ swap\ them.}}
\DoxyCodeLine{00081\ \textcolor{comment}{}\ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ ((*nums)[i]\ >\ (*nums)[i\ +\ 1])\ \{}
\DoxyCodeLine{00082\ \ \ \ \ \ \ \ \ \ \ \ \ std::swap((*nums)[i],\ (*nums)[i\ +\ 1]);}
\DoxyCodeLine{00083\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00084\ \ \ \ \ \}}
\DoxyCodeLine{00085\ \textcolor{comment}{}}
\DoxyCodeLine{00086\ \textcolor{comment}{\ \ \ \ //!<\ calling\ the\ function\ after\ we\ have\ fixed\ the\ last\ element}}
\DoxyCodeLine{00087\ \textcolor{comment}{}\ \ \ \ \mbox{\hyperlink{namespacesorting_ae3a775d99dbbb94c130a973df0cfddcf}{recursive\_bubble\_sort}}(nums,\ n\ -\/\ 1);}
\DoxyCodeLine{00088\ \}}

\end{DoxyCode}
\Hypertarget{namespacesorting_a06af4f0dae2de2a2ae5b797d7aa26755}\index{sorting@{sorting}!selectionSort@{selectionSort}}
\index{selectionSort@{selectionSort}!sorting@{sorting}}
\doxysubsubsection{\texorpdfstring{selectionSort()}{selectionSort()}}
{\footnotesize\ttfamily \label{namespacesorting_a06af4f0dae2de2a2ae5b797d7aa26755} 
std\+::vector$<$ uint64\+\_\+t $>$ sorting\+::selection\+Sort (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ uint64\+\_\+t $>$ \&}]{arr}{, }\item[{uint64\+\_\+t}]{len}{}\end{DoxyParamCaption})}


\begin{DoxyCode}{0}
\DoxyCodeLine{00048\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00049\ \ \ \ \ std::vector<uint64\_t>\ array(}
\DoxyCodeLine{00050\ \ \ \ \ \ \ \ \ arr.begin(),}
\DoxyCodeLine{00051\ \ \ \ \ \ \ \ \ arr.end());\ \ \textcolor{comment}{//\ declare\ a\ vector\ in\ which\ result\ will\ be\ stored}}
\DoxyCodeLine{00052\ \ \ \ \ \textcolor{keywordflow}{for}\ (uint64\_t\ it\ =\ 0;\ it\ <\ len;\ ++it)\ \{}
\DoxyCodeLine{00053\ \ \ \ \ \ \ \ \ uint64\_t\ min\ =\ it;\ \ \textcolor{comment}{//\ set\ min\ value}}
\DoxyCodeLine{00054\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (uint64\_t\ it2\ =\ it\ +\ 1;\ it2\ <\ len;\ ++it2)\ \{}
\DoxyCodeLine{00055\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (array[it2]\ <\ array[min])\ \{\ \ \textcolor{comment}{//\ check\ which\ element\ is\ smaller}}
\DoxyCodeLine{00056\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ min\ =\ it2;\ \ \textcolor{comment}{//\ store\ index\ of\ smallest\ element\ to\ min}}
\DoxyCodeLine{00057\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00058\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00059\ }
\DoxyCodeLine{00060\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (min\ !=\ it)\ \{\ \ \textcolor{comment}{//\ swap\ if\ min\ does\ not\ match\ to\ i}}
\DoxyCodeLine{00061\ \ \ \ \ \ \ \ \ \ \ \ \ uint64\_t\ tmp\ =\ array[min];}
\DoxyCodeLine{00062\ \ \ \ \ \ \ \ \ \ \ \ \ array[min]\ =\ array[it];}
\DoxyCodeLine{00063\ \ \ \ \ \ \ \ \ \ \ \ \ array[it]\ =\ tmp;}
\DoxyCodeLine{00064\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00065\ \ \ \ \ \}}
\DoxyCodeLine{00066\ }
\DoxyCodeLine{00067\ \ \ \ \ \textcolor{keywordflow}{return}\ array;\ \ \textcolor{comment}{//\ return\ sorted\ vector}}
\DoxyCodeLine{00068\ \}}

\end{DoxyCode}
\Hypertarget{namespacesorting_af2c5b92cbfe73f63f6074c61b0a45331}\index{sorting@{sorting}!shell\_sort@{shell\_sort}}
\index{shell\_sort@{shell\_sort}!sorting@{sorting}}
\doxysubsubsection{\texorpdfstring{shell\_sort()}{shell\_sort()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily \label{namespacesorting_af2c5b92cbfe73f63f6074c61b0a45331} 
template$<$typename T $>$ \\
void sorting\+::shell\+\_\+sort (\begin{DoxyParamCaption}\item[{std\+::vector$<$ T $>$ \texorpdfstring{$\ast$}{*}}]{arr}{}\end{DoxyParamCaption})}

function overload -\/ when input array is of type std\+::vector, simply send the data content and the data length to the above function. 
\begin{DoxyCode}{0}
\DoxyCodeLine{00075\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00076\ \ \ \ \ shell\_sort(arr-\/>data(),\ arr-\/>size());}
\DoxyCodeLine{00077\ \}}

\end{DoxyCode}
\Hypertarget{namespacesorting_a5669396c6a6b1e14b97589b6e37980aa}\index{sorting@{sorting}!shell\_sort@{shell\_sort}}
\index{shell\_sort@{shell\_sort}!sorting@{sorting}}
\doxysubsubsection{\texorpdfstring{shell\_sort()}{shell\_sort()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily \label{namespacesorting_a5669396c6a6b1e14b97589b6e37980aa} 
template$<$typename T $>$ \\
void sorting\+::shell\+\_\+sort (\begin{DoxyParamCaption}\item[{T \texorpdfstring{$\ast$}{*}}]{arr}{, }\item[{size\+\_\+t}]{LEN}{}\end{DoxyParamCaption})}

Optimized algorithm -\/ takes half the time by utilizing Mar 
\begin{DoxyCode}{0}
\DoxyCodeLine{00045\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00046\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{int}\ gaps[]\ =\ \{701,\ 301,\ 132,\ 57,\ 23,\ 10,\ 4,\ 1\};}
\DoxyCodeLine{00047\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{int}\ gap\_len\ =\ 8;}
\DoxyCodeLine{00048\ \ \ \ \ \textcolor{keywordtype}{size\_t}\ i,\ j,\ g;}
\DoxyCodeLine{00049\ }
\DoxyCodeLine{00050\ \ \ \ \ \textcolor{keywordflow}{for}\ (g\ =\ 0;\ g\ <\ gap\_len;\ g++)\ \{}
\DoxyCodeLine{00051\ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{int}\ gap\ =\ gaps[g];}
\DoxyCodeLine{00052\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (i\ =\ gap;\ i\ <\ LEN;\ i++)\ \{}
\DoxyCodeLine{00053\ \ \ \ \ \ \ \ \ \ \ \ \ T\ tmp\ =\ arr[i];}
\DoxyCodeLine{00054\ }
\DoxyCodeLine{00055\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (j\ =\ i;\ j\ >=\ gap\ \&\&\ (arr[j\ -\/\ gap]\ -\/\ tmp)\ >\ 0;\ j\ -\/=\ gap)\ \{}
\DoxyCodeLine{00056\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ arr[j]\ =\ arr[j\ -\/\ gap];}
\DoxyCodeLine{00057\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00058\ }
\DoxyCodeLine{00059\ \ \ \ \ \ \ \ \ \ \ \ \ arr[j]\ =\ tmp;}
\DoxyCodeLine{00060\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00061\ \ \ \ \ \}}
\DoxyCodeLine{00062\ \}}

\end{DoxyCode}
\Hypertarget{namespacesorting_a4d76603c54d3dc56146e92d10a043924}\index{sorting@{sorting}!shell\_sort@{shell\_sort}}
\index{shell\_sort@{shell\_sort}!sorting@{sorting}}
\doxysubsubsection{\texorpdfstring{shell\_sort()}{shell\_sort()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily \label{namespacesorting_a4d76603c54d3dc56146e92d10a043924} 
template$<$typename T , size\+\_\+t N$>$ \\
void sorting\+::shell\+\_\+sort (\begin{DoxyParamCaption}\item[{T(\&)}]{arr}{\mbox{[}\+N\mbox{]}}\end{DoxyParamCaption})}

function overload -\/ when input array is of a known length array type 
\begin{DoxyCode}{0}
\DoxyCodeLine{00067\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00068\ \ \ \ \ shell\_sort(arr,\ N);}
\DoxyCodeLine{00069\ \}}

\end{DoxyCode}
\Hypertarget{namespacesorting_a7bfe11bd4703eacd1dab93f25ec639c5}\index{sorting@{sorting}!shuffle@{shuffle}}
\index{shuffle@{shuffle}!sorting@{sorting}}
\doxysubsubsection{\texorpdfstring{shuffle()}{shuffle()}}
{\footnotesize\ttfamily \label{namespacesorting_a7bfe11bd4703eacd1dab93f25ec639c5} 
template$<$typename T , size\+\_\+t N$>$ \\
std\+::array$<$ T, N $>$ sorting\+::shuffle (\begin{DoxyParamCaption}\item[{std\+::array$<$ T, N $>$}]{arr}{}\end{DoxyParamCaption})}

Function to shuffle the elements of an array. (for reference) 
\begin{DoxyTemplParams}{Template Parameters}
{\em T} & typename of the array \\
\hline
{\em N} & length of array \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em arr} & array to shuffle \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
new array with elements shuffled from a given array 
\end{DoxyReturn}

\begin{DoxyCode}{0}
\DoxyCodeLine{00037\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00038\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{int}\ i\ =\ 0;\ i\ <\ N;\ i++)\ \{}
\DoxyCodeLine{00039\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Swaps\ i'th\ \ index\ with\ random\ index\ (less\ than\ array\ size)}}
\DoxyCodeLine{00040\ \ \ \ \ \ \ \ \ std::swap(arr[i],\ arr[std::rand()\ \%\ N]);}
\DoxyCodeLine{00041\ \ \ \ \ \}}
\DoxyCodeLine{00042\ \ \ \ \ \textcolor{keywordflow}{return}\ arr;}
\DoxyCodeLine{00043\ \}}

\end{DoxyCode}
