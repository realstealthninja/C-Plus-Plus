\doxysection{graph Namespace Reference}
\hypertarget{namespacegraph}{}\label{namespacegraph}\index{graph@{graph}}


\doxylink{classgraph_1_1_graph}{Graph} Algorithms.  


\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classgraph_1_1_graph}{Graph}}
\item 
class \mbox{\hyperlink{classgraph_1_1_h_k_graph}{HKGraph}}
\begin{DoxyCompactList}\small\item\em Represents Bipartite graph for Hopcroft Karp implementation. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classgraph_1_1_lowest_common_ancestor}{Lowest\+Common\+Ancestor}}
\item 
class \mbox{\hyperlink{classgraph_1_1_rooted_tree}{Rooted\+Tree}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{namespacegraph_a9125ceb66bfbec3093bba64c2c1e99e2}{add\+Edge}} (std\+::vector$<$ std\+::vector$<$ int $>$ $>$ \texorpdfstring{$\ast$}{*}adj, int u, int v)
\begin{DoxyCompactList}\small\item\em Function that add edge between two nodes or vertices of graph. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacegraph_a3ae80bc4c6a79d041b4f3a6589eb7fb8}{explore}} (const std\+::vector$<$ std\+::vector$<$ int $>$ $>$ \texorpdfstring{$\ast$}{*}adj, int u, std\+::vector$<$ bool $>$ \texorpdfstring{$\ast$}{*}visited)
\begin{DoxyCompactList}\small\item\em Utility function for depth first seach algorithm this function explores the vertex which is passed into. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{namespacegraph_a83ab16e96cec644109a58dfc9329bc2b}{get\+Connected\+Components}} (const std\+::vector$<$ std\+::vector$<$ int $>$ $>$ \texorpdfstring{$\ast$}{*}adj)
\begin{DoxyCompactList}\small\item\em Function that perfoms depth first search algorithm on graph and calculated the number of connected components. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacegraph_ad4016cfc80485a43748895a2c26c7d08}{add\+Edge}} (std\+::vector$<$ std\+::vector$<$ size\+\_\+t $>$ $>$ \texorpdfstring{$\ast$}{*}adj, size\+\_\+t u, size\+\_\+t v)
\begin{DoxyCompactList}\small\item\em Adds and edge between two vertices of graph say u and v in this case. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacegraph_a64c1db5aad7502c6f08e4652f6edd463}{explore}} (const std\+::vector$<$ std\+::vector$<$ size\+\_\+t $>$ $>$ \&adj, size\+\_\+t v, std\+::vector$<$ bool $>$ \texorpdfstring{$\ast$}{*}visited)
\begin{DoxyCompactList}\small\item\em Explores the given vertex, exploring a vertex means traversing over all the vertices which are connected to the vertex that is currently being explored. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacegraph_ab5428a3519267a28bba4b4310cfbb6ae}{depth\+\_\+first\+\_\+search}} (const std\+::vector$<$ std\+::vector$<$ size\+\_\+t $>$ $>$ \&adj, size\+\_\+t start)
\begin{DoxyCompactList}\small\item\em initiates depth first search algorithm. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacegraph_a0e30e0dca68cb6e4f671440819b35b6a}{add\+Edge}} (std\+::vector$<$ std\+::vector$<$ std\+::pair$<$ int, int $>$ $>$ $>$ \texorpdfstring{$\ast$}{*}adj, int u, int v, int w)
\begin{DoxyCompactList}\small\item\em Function that add edge between two nodes or vertices of graph. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{namespacegraph_adc68cbc8ba09eb1142265935c0d45b84}{dijkstra}} (std\+::vector$<$ std\+::vector$<$ std\+::pair$<$ int, int $>$ $>$ $>$ \texorpdfstring{$\ast$}{*}adj, int s, int t)
\begin{DoxyCompactList}\small\item\em Function runs the dijkstra algorithm for some source vertex and target vertex in the graph and returns the shortest distance of target from the source. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespacegraph_a8e1b547cd407c0774e63f0dc95cda9e7}{check\+Bipartite}} (const std\+::vector$<$ std\+::vector$<$ int64\+\_\+t $>$ $>$ \&graph, int64\+\_\+t index, std\+::vector$<$ int64\+\_\+t $>$ \texorpdfstring{$\ast$}{*}visited)
\begin{DoxyCompactList}\small\item\em function to check whether the passed graph is bipartite or not \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespacegraph_a84b0551489c613a681cc83b34450da4b}{is\+Bipartite}} (const std\+::vector$<$ std\+::vector$<$ int64\+\_\+t $>$ $>$ \&graph)
\begin{DoxyCompactList}\small\item\em returns true if the given graph is bipartite else returns false \end{DoxyCompactList}\item 
int \mbox{\hyperlink{namespacegraph_ab7706341d006e20d1ae58274187a3346}{Travelling\+Salesman\+Problem}} (std\+::vector$<$ std\+::vector$<$ uint32\+\_\+t $>$ $>$ \texorpdfstring{$\ast$}{*}cities, int32\+\_\+t src, uint32\+\_\+t V)
\begin{DoxyCompactList}\small\item\em Function calculates the minimum path distance that will cover all the cities starting from the source. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\doxylink{classgraph_1_1_graph}{Graph} Algorithms. 

Check whether a given graph is bipartite or not.

for std\+::vector

\doxylink{classgraph_1_1_graph}{Graph} algorithms.

for IO operations for std\+::set

\doxylink{classgraph_1_1_graph}{Graph} Algorithms

A bipartite graph is the one whose nodes can be divided into two disjoint sets in such a way that the nodes in a set are not connected to each other at all, i.\+e. no intra-\/set connections. The only connections that exist are that of inter-\/set, i.\+e. the nodes from one set are connected to a subset of nodes in the other set. In this implementation, using a graph in the form of adjacency list, check whether the given graph is a bipartite or not.

References used\+: \href{https://www.geeksforgeeks.org/bipartite-graph/}{\texttt{ Geeks\+For\+Geeks}} \begin{DoxyAuthor}{Author}
\href{https://github.com/tushar2407}{\texttt{ tushar2407}} for assert for IO operations for queue data structure for vector data structure
\end{DoxyAuthor}
Graphical algorithms

for std\+::min for assert for IO operations for limits of integral types for std\+::vector 

\doxysubsection{Function Documentation}
\Hypertarget{namespacegraph_a9125ceb66bfbec3093bba64c2c1e99e2}\index{graph@{graph}!addEdge@{addEdge}}
\index{addEdge@{addEdge}!graph@{graph}}
\doxysubsubsection{\texorpdfstring{addEdge()}{addEdge()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily \label{namespacegraph_a9125ceb66bfbec3093bba64c2c1e99e2} 
void graph\+::add\+Edge (\begin{DoxyParamCaption}\item[{std\+::vector$<$ std\+::vector$<$ int $>$ $>$ \texorpdfstring{$\ast$}{*}}]{adj}{, }\item[{int}]{u}{, }\item[{int}]{v}{}\end{DoxyParamCaption})}



Function that add edge between two nodes or vertices of graph. 


\begin{DoxyParams}{Parameters}
{\em adj} & adjacency list of graph. \\
\hline
{\em u} & any node or vertex of graph. \\
\hline
{\em v} & any node or vertex of graph. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{00046\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00047\ \ \ \ \ (*adj)[u\ -\/\ 1].push\_back(v\ -\/\ 1);}
\DoxyCodeLine{00048\ \ \ \ \ (*adj)[v\ -\/\ 1].push\_back(u\ -\/\ 1);}
\DoxyCodeLine{00049\ \}}

\end{DoxyCode}
\Hypertarget{namespacegraph_ad4016cfc80485a43748895a2c26c7d08}\index{graph@{graph}!addEdge@{addEdge}}
\index{addEdge@{addEdge}!graph@{graph}}
\doxysubsubsection{\texorpdfstring{addEdge()}{addEdge()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily \label{namespacegraph_ad4016cfc80485a43748895a2c26c7d08} 
void graph\+::add\+Edge (\begin{DoxyParamCaption}\item[{std\+::vector$<$ std\+::vector$<$ size\+\_\+t $>$ $>$ \texorpdfstring{$\ast$}{*}}]{adj}{, }\item[{size\+\_\+t}]{u}{, }\item[{size\+\_\+t}]{v}{}\end{DoxyParamCaption})}



Adds and edge between two vertices of graph say u and v in this case. 


\begin{DoxyParams}{Parameters}
{\em adj} & Adjacency list representation of graph \\
\hline
{\em u} & first vertex \\
\hline
{\em v} & second vertex \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{00056\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00057\ \ \ \ \ \textcolor{comment}{/*}}
\DoxyCodeLine{00058\ \textcolor{comment}{\ \ \ \ \ *}}
\DoxyCodeLine{00059\ \textcolor{comment}{\ \ \ \ \ *\ Here\ we\ are\ considering\ undirected\ graph\ that's\ the}}
\DoxyCodeLine{00060\ \textcolor{comment}{\ \ \ \ \ *\ reason\ we\ are\ adding\ v\ to\ the\ adjacency\ list\ representation\ of\ u}}
\DoxyCodeLine{00061\ \textcolor{comment}{\ \ \ \ \ *\ and\ also\ adding\ u\ to\ the\ adjacency\ list\ representation\ of\ v}}
\DoxyCodeLine{00062\ \textcolor{comment}{\ \ \ \ \ *}}
\DoxyCodeLine{00063\ \textcolor{comment}{\ \ \ \ \ */}}
\DoxyCodeLine{00064\ \ \ \ \ (*adj)[u\ -\/\ 1].push\_back(v\ -\/\ 1);}
\DoxyCodeLine{00065\ \ \ \ \ (*adj)[v\ -\/\ 1].push\_back(u\ -\/\ 1);}
\DoxyCodeLine{00066\ \}}

\end{DoxyCode}
\Hypertarget{namespacegraph_a0e30e0dca68cb6e4f671440819b35b6a}\index{graph@{graph}!addEdge@{addEdge}}
\index{addEdge@{addEdge}!graph@{graph}}
\doxysubsubsection{\texorpdfstring{addEdge()}{addEdge()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily \label{namespacegraph_a0e30e0dca68cb6e4f671440819b35b6a} 
void graph\+::add\+Edge (\begin{DoxyParamCaption}\item[{std\+::vector$<$ std\+::vector$<$ std\+::pair$<$ int, int $>$ $>$ $>$ \texorpdfstring{$\ast$}{*}}]{adj}{, }\item[{int}]{u}{, }\item[{int}]{v}{, }\item[{int}]{w}{}\end{DoxyParamCaption})}



Function that add edge between two nodes or vertices of graph. 


\begin{DoxyParams}{Parameters}
{\em u} & any node or vertex of graph \\
\hline
{\em v} & any node or vertex of graph \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{00049\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00050\ \ \ \ \ (*adj)[u\ -\/\ 1].push\_back(std::make\_pair(v\ -\/\ 1,\ w));}
\DoxyCodeLine{00051\ \ \ \ \ \textcolor{comment}{//\ (*adj)[v\ -\/\ 1].push\_back(std::make\_pair(u\ -\/\ 1,\ w));}}
\DoxyCodeLine{00052\ \}}

\end{DoxyCode}
\Hypertarget{namespacegraph_a8e1b547cd407c0774e63f0dc95cda9e7}\index{graph@{graph}!checkBipartite@{checkBipartite}}
\index{checkBipartite@{checkBipartite}!graph@{graph}}
\doxysubsubsection{\texorpdfstring{checkBipartite()}{checkBipartite()}}
{\footnotesize\ttfamily \label{namespacegraph_a8e1b547cd407c0774e63f0dc95cda9e7} 
bool graph\+::check\+Bipartite (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ std\+::vector$<$ int64\+\_\+t $>$ $>$ \&}]{graph}{, }\item[{int64\+\_\+t}]{index}{, }\item[{std\+::vector$<$ int64\+\_\+t $>$ \texorpdfstring{$\ast$}{*}}]{visited}{}\end{DoxyParamCaption})}



function to check whether the passed graph is bipartite or not 


\begin{DoxyParams}{Parameters}
{\em graph} & is a 2D matrix whose rows or the first index signify the node and values in that row signify the nodes it is connected to \\
\hline
{\em index} & is the valus of the node currently under observation \\
\hline
{\em visited} & is the vector which stores whether a given node has been traversed or not yet \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
boolean 
\end{DoxyReturn}
\texorpdfstring{$<$}{<} stores the neighbouring node indexes in squence of being reached

insert the current node into the queue

mark the current node as travelled

\texorpdfstring{$<$}{<} stores the neighbour of the current node

check whether the neighbour node is travelled already or not

colour the neighbouring node with different colour than the current node

insert the neighbouring node into the queue

if both the current node and its neighbour has the same state then it is not a bipartite graph

return true when all the connected nodes of the current nodes are travelled and satisify all the above conditions
\begin{DoxyCode}{0}
\DoxyCodeLine{00037\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00038\ \ \ \ \ std::queue<int64\_t>\ q;\ \ \textcolor{comment}{///<\ stores\ the\ neighbouring\ node\ indexes\ in\ squence}\textcolor{comment}{}}
\DoxyCodeLine{00039\ \textcolor{comment}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ///\ of\ being\ reached}}
\DoxyCodeLine{00040\ \textcolor{comment}{}\ \ \ \ q.push(index);\ \ \ \ \ \ \ \ \ \ \textcolor{comment}{///\ insert\ the\ current\ node\ into\ the\ queue}}
\DoxyCodeLine{00041\ \ \ \ \ (*visited)[index]\ =\ 1;\ \ \textcolor{comment}{///\ mark\ the\ current\ node\ as\ travelled}}
\DoxyCodeLine{00042\ \ \ \ \ \textcolor{keywordflow}{while}\ (q.size())\ \{}
\DoxyCodeLine{00043\ \ \ \ \ \ \ \ \ int64\_t\ u\ =\ q.front();}
\DoxyCodeLine{00044\ \ \ \ \ \ \ \ \ q.pop();}
\DoxyCodeLine{00045\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (uint64\_t\ i\ =\ 0;\ i\ <\ \mbox{\hyperlink{namespacegraph}{graph}}[u].size();\ i++)\ \{}
\DoxyCodeLine{00046\ \ \ \ \ \ \ \ \ \ \ \ \ int64\_t\ v\ =}
\DoxyCodeLine{00047\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{namespacegraph}{graph}}[u][i];\ \ \ \ \ \textcolor{comment}{///<\ stores\ the\ neighbour\ of\ the\ current\ node}}
\DoxyCodeLine{00048\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!(*visited)[v])\ \ \textcolor{comment}{///\ check\ whether\ the\ neighbour\ node\ is}\textcolor{comment}{}}
\DoxyCodeLine{00049\ \textcolor{comment}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ///\ travelled\ already\ or\ not}}
\DoxyCodeLine{00050\ \textcolor{comment}{}\ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00051\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (*visited)[v]\ =}
\DoxyCodeLine{00052\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ((*visited)[u]\ ==\ 1)}
\DoxyCodeLine{00053\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ?\ -\/1}
\DoxyCodeLine{00054\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :\ 1;\ \ \textcolor{comment}{///\ colour\ the\ neighbouring\ node\ with}\textcolor{comment}{}}
\DoxyCodeLine{00055\ \textcolor{comment}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ///\ different\ colour\ than\ the\ current\ node}}
\DoxyCodeLine{00056\ \textcolor{comment}{}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ q.push(v);\ \ \ \ \textcolor{comment}{///\ insert\ the\ neighbouring\ node\ into\ the\ queue}}
\DoxyCodeLine{00057\ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ ((*visited)[v]\ ==}
\DoxyCodeLine{00058\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (*visited)[u])\ \ \textcolor{comment}{///\ if\ both\ the\ current\ node\ and\ its}\textcolor{comment}{}}
\DoxyCodeLine{00059\ \textcolor{comment}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ///\ neighbour\ has\ the\ same\ state\ then\ it}}
\DoxyCodeLine{00060\ \textcolor{comment}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ///\ is\ not\ a\ bipartite\ graph}}
\DoxyCodeLine{00061\ \textcolor{comment}{}\ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00062\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{00063\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00064\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00065\ \ \ \ \ \}}
\DoxyCodeLine{00066\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};\ \ \textcolor{comment}{///\ return\ true\ when\ all\ the\ connected\ nodes\ of\ the\ current}\textcolor{comment}{}}
\DoxyCodeLine{00067\ \textcolor{comment}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ///\ nodes\ are\ travelled\ and\ satisify\ all\ the\ above\ conditions}}
\DoxyCodeLine{00068\ \textcolor{comment}{}\}}

\end{DoxyCode}
\Hypertarget{namespacegraph_ab5428a3519267a28bba4b4310cfbb6ae}\index{graph@{graph}!depth\_first\_search@{depth\_first\_search}}
\index{depth\_first\_search@{depth\_first\_search}!graph@{graph}}
\doxysubsubsection{\texorpdfstring{depth\_first\_search()}{depth\_first\_search()}}
{\footnotesize\ttfamily \label{namespacegraph_ab5428a3519267a28bba4b4310cfbb6ae} 
void graph\+::depth\+\_\+first\+\_\+search (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ std\+::vector$<$ size\+\_\+t $>$ $>$ \&}]{adj}{, }\item[{size\+\_\+t}]{start}{}\end{DoxyParamCaption})}



initiates depth first search algorithm. 


\begin{DoxyParams}{Parameters}
{\em adj} & adjacency list of graph \\
\hline
{\em start} & vertex from where DFS starts traversing. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{00100\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00101\ \ \ \ \ \textcolor{keywordtype}{size\_t}\ vertices\ =\ adj.size();}
\DoxyCodeLine{00102\ }
\DoxyCodeLine{00103\ \ \ \ \ std::vector<bool>\ visited(vertices,\ \textcolor{keyword}{false});}
\DoxyCodeLine{00104\ \ \ \ \ \mbox{\hyperlink{namespacegraph_a3ae80bc4c6a79d041b4f3a6589eb7fb8}{explore}}(adj,\ start,\ \&visited);}
\DoxyCodeLine{00105\ \}}

\end{DoxyCode}
\Hypertarget{namespacegraph_adc68cbc8ba09eb1142265935c0d45b84}\index{graph@{graph}!dijkstra@{dijkstra}}
\index{dijkstra@{dijkstra}!graph@{graph}}
\doxysubsubsection{\texorpdfstring{dijkstra()}{dijkstra()}}
{\footnotesize\ttfamily \label{namespacegraph_adc68cbc8ba09eb1142265935c0d45b84} 
int graph\+::dijkstra (\begin{DoxyParamCaption}\item[{std\+::vector$<$ std\+::vector$<$ std\+::pair$<$ int, int $>$ $>$ $>$ \texorpdfstring{$\ast$}{*}}]{adj}{, }\item[{int}]{s}{, }\item[{int}]{t}{}\end{DoxyParamCaption})}



Function runs the dijkstra algorithm for some source vertex and target vertex in the graph and returns the shortest distance of target from the source. 


\begin{DoxyParams}{Parameters}
{\em adj} & input graph \\
\hline
{\em s} & source vertex \\
\hline
{\em t} & target vertex\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
shortest distance if target is reachable from source else -\/1 in case if target is not reachable from source. 
\end{DoxyReturn}
n denotes the number of vertices in graph

setting all the distances initially to INF

creating a min heap using priority queue first element of pair contains the distance second element of pair contains the vertex

pushing the source vertex \textquotesingle{}s\textquotesingle{} with 0 distance in min heap

marking the distance of source as 0

second element of pair denotes the node / vertex

first element of pair denotes the distance

for all the reachable vertex from the currently exploring vertex we will try to minimize the distance

minimizing distances
\begin{DoxyCode}{0}
\DoxyCodeLine{00066\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{\textcolor{comment}{}}
\DoxyCodeLine{00067\ \textcolor{comment}{\ \ \ \ ///\ n\ denotes\ the\ number\ of\ vertices\ in\ graph}}
\DoxyCodeLine{00068\ \textcolor{comment}{}\ \ \ \ \textcolor{keywordtype}{int}\ n\ =\ adj-\/>size();}
\DoxyCodeLine{00069\ \textcolor{comment}{}}
\DoxyCodeLine{00070\ \textcolor{comment}{\ \ \ \ ///\ setting\ all\ the\ distances\ initially\ to\ INF}}
\DoxyCodeLine{00071\ \textcolor{comment}{}\ \ \ \ std::vector<int64\_t>\ dist(n,\ INF);}
\DoxyCodeLine{00072\ \textcolor{comment}{}}
\DoxyCodeLine{00073\ \textcolor{comment}{\ \ \ \ ///\ creating\ a\ min\ heap\ using\ priority\ queue}}
\DoxyCodeLine{00074\ \textcolor{comment}{\ \ \ \ ///\ first\ element\ of\ pair\ contains\ the\ distance}}
\DoxyCodeLine{00075\ \textcolor{comment}{\ \ \ \ ///\ second\ element\ of\ pair\ contains\ the\ vertex}}
\DoxyCodeLine{00076\ \textcolor{comment}{}\ \ \ \ std::priority\_queue<std::pair<int,\ int>,\ std::vector<std::pair<int,\ int>>,}
\DoxyCodeLine{00077\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::greater<std::pair<int,\ int>>>}
\DoxyCodeLine{00078\ \ \ \ \ \ \ \ \ pq;}
\DoxyCodeLine{00079\ \textcolor{comment}{}}
\DoxyCodeLine{00080\ \textcolor{comment}{\ \ \ \ ///\ pushing\ the\ source\ vertex\ 's'\ with\ 0\ distance\ in\ min\ heap}}
\DoxyCodeLine{00081\ \textcolor{comment}{}\ \ \ \ pq.push(std::make\_pair(0,\ s));}
\DoxyCodeLine{00082\ \textcolor{comment}{}}
\DoxyCodeLine{00083\ \textcolor{comment}{\ \ \ \ ///\ marking\ the\ distance\ of\ source\ as\ 0}}
\DoxyCodeLine{00084\ \textcolor{comment}{}\ \ \ \ dist[s]\ =\ 0;}
\DoxyCodeLine{00085\ }
\DoxyCodeLine{00086\ \ \ \ \ \textcolor{keywordflow}{while}\ (!pq.empty())\ \{\textcolor{comment}{}}
\DoxyCodeLine{00087\ \textcolor{comment}{\ \ \ \ \ \ \ \ ///\ second\ element\ of\ pair\ denotes\ the\ node\ /\ vertex}}
\DoxyCodeLine{00088\ \textcolor{comment}{}\ \ \ \ \ \ \ \ \textcolor{keywordtype}{int}\ currentNode\ =\ pq.top().second;}
\DoxyCodeLine{00089\ \textcolor{comment}{}}
\DoxyCodeLine{00090\ \textcolor{comment}{\ \ \ \ \ \ \ \ ///\ first\ element\ of\ pair\ denotes\ the\ distance}}
\DoxyCodeLine{00091\ \textcolor{comment}{}\ \ \ \ \ \ \ \ \textcolor{keywordtype}{int}\ currentDist\ =\ pq.top().first;}
\DoxyCodeLine{00092\ }
\DoxyCodeLine{00093\ \ \ \ \ \ \ \ \ pq.pop();}
\DoxyCodeLine{00094\ \textcolor{comment}{}}
\DoxyCodeLine{00095\ \textcolor{comment}{\ \ \ \ \ \ \ \ ///\ for\ all\ the\ reachable\ vertex\ from\ the\ currently\ exploring\ vertex}}
\DoxyCodeLine{00096\ \textcolor{comment}{\ \ \ \ \ \ \ \ ///\ we\ will\ try\ to\ minimize\ the\ distance}}
\DoxyCodeLine{00097\ \textcolor{comment}{}\ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (std::pair<int,\ int>\ edge\ :\ (*adj)[currentNode])\ \{\textcolor{comment}{}}
\DoxyCodeLine{00098\ \textcolor{comment}{\ \ \ \ \ \ \ \ \ \ \ \ ///\ minimizing\ distances}}
\DoxyCodeLine{00099\ \textcolor{comment}{}\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (currentDist\ +\ edge.second\ <\ dist[edge.first])\ \{}
\DoxyCodeLine{00100\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ dist[edge.first]\ =\ currentDist\ +\ edge.second;}
\DoxyCodeLine{00101\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ pq.push(std::make\_pair(dist[edge.first],\ edge.first));}
\DoxyCodeLine{00102\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00103\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00104\ \ \ \ \ \}}
\DoxyCodeLine{00105\ \ \ \ \ \textcolor{keywordflow}{if}\ (dist[t]\ !=\ INF)\ \{}
\DoxyCodeLine{00106\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ dist[t];}
\DoxyCodeLine{00107\ \ \ \ \ \}}
\DoxyCodeLine{00108\ \ \ \ \ \textcolor{keywordflow}{return}\ -\/1;}
\DoxyCodeLine{00109\ \}}

\end{DoxyCode}
\Hypertarget{namespacegraph_a3ae80bc4c6a79d041b4f3a6589eb7fb8}\index{graph@{graph}!explore@{explore}}
\index{explore@{explore}!graph@{graph}}
\doxysubsubsection{\texorpdfstring{explore()}{explore()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{namespacegraph_a3ae80bc4c6a79d041b4f3a6589eb7fb8} 
void graph\+::explore (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ std\+::vector$<$ int $>$ $>$ \texorpdfstring{$\ast$}{*}}]{adj}{, }\item[{int}]{u}{, }\item[{std\+::vector$<$ bool $>$ \texorpdfstring{$\ast$}{*}}]{visited}{}\end{DoxyParamCaption})}



Utility function for depth first seach algorithm this function explores the vertex which is passed into. 


\begin{DoxyParams}{Parameters}
{\em adj} & adjacency list of graph. \\
\hline
{\em u} & vertex or node to be explored. \\
\hline
{\em visited} & already visited vertices. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{00060\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00061\ \ \ \ \ (*visited)[u]\ =\ \textcolor{keyword}{true};}
\DoxyCodeLine{00062\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{auto}\ v\ :\ (*adj)[u])\ \{}
\DoxyCodeLine{00063\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!(*visited)[v])\ \{}
\DoxyCodeLine{00064\ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{namespacegraph_a3ae80bc4c6a79d041b4f3a6589eb7fb8}{explore}}(adj,\ v,\ visited);}
\DoxyCodeLine{00065\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00066\ \ \ \ \ \}}
\DoxyCodeLine{00067\ \}}

\end{DoxyCode}
\Hypertarget{namespacegraph_a64c1db5aad7502c6f08e4652f6edd463}\index{graph@{graph}!explore@{explore}}
\index{explore@{explore}!graph@{graph}}
\doxysubsubsection{\texorpdfstring{explore()}{explore()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{namespacegraph_a64c1db5aad7502c6f08e4652f6edd463} 
void graph\+::explore (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ std\+::vector$<$ size\+\_\+t $>$ $>$ \&}]{adj}{, }\item[{size\+\_\+t}]{v}{, }\item[{std\+::vector$<$ bool $>$ \texorpdfstring{$\ast$}{*}}]{visited}{}\end{DoxyParamCaption})}



Explores the given vertex, exploring a vertex means traversing over all the vertices which are connected to the vertex that is currently being explored. 


\begin{DoxyParams}{Parameters}
{\em adj} & garph \\
\hline
{\em v} & vertex to be explored \\
\hline
{\em visited} & already visited vertices \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{00081\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00082\ \ \ \ \ std::cout\ <<\ v\ +\ 1\ <<\ \textcolor{stringliteral}{"{}\ "{}};}
\DoxyCodeLine{00083\ \ \ \ \ (*visited)[v]\ =\ \textcolor{keyword}{true};}
\DoxyCodeLine{00084\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{auto}\ x\ :\ adj[v])\ \{}
\DoxyCodeLine{00085\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!(*visited)[x])\ \{}
\DoxyCodeLine{00086\ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{namespacegraph_a3ae80bc4c6a79d041b4f3a6589eb7fb8}{explore}}(adj,\ x,\ visited);}
\DoxyCodeLine{00087\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00088\ \ \ \ \ \}}
\DoxyCodeLine{00089\ \}}

\end{DoxyCode}
\Hypertarget{namespacegraph_a83ab16e96cec644109a58dfc9329bc2b}\index{graph@{graph}!getConnectedComponents@{getConnectedComponents}}
\index{getConnectedComponents@{getConnectedComponents}!graph@{graph}}
\doxysubsubsection{\texorpdfstring{getConnectedComponents()}{getConnectedComponents()}}
{\footnotesize\ttfamily \label{namespacegraph_a83ab16e96cec644109a58dfc9329bc2b} 
int graph\+::get\+Connected\+Components (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ std\+::vector$<$ int $>$ $>$ \texorpdfstring{$\ast$}{*}}]{adj}{}\end{DoxyParamCaption})}



Function that perfoms depth first search algorithm on graph and calculated the number of connected components. 


\begin{DoxyParams}{Parameters}
{\em adj} & adjacency list of graph.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
connected\+\_\+components number of connected components in graph. 
\end{DoxyReturn}

\begin{DoxyCode}{0}
\DoxyCodeLine{00077\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00078\ \ \ \ \ \textcolor{keywordtype}{int}\ n\ =\ adj-\/>size();}
\DoxyCodeLine{00079\ \ \ \ \ \textcolor{keywordtype}{int}\ connected\_components\ =\ 0;}
\DoxyCodeLine{00080\ \ \ \ \ std::vector<bool>\ visited(n,\ \textcolor{keyword}{false});}
\DoxyCodeLine{00081\ }
\DoxyCodeLine{00082\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{int}\ i\ =\ 0;\ i\ <\ n;\ i++)\ \{}
\DoxyCodeLine{00083\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!visited[i])\ \{}
\DoxyCodeLine{00084\ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{namespacegraph_a3ae80bc4c6a79d041b4f3a6589eb7fb8}{explore}}(adj,\ i,\ \&visited);}
\DoxyCodeLine{00085\ \ \ \ \ \ \ \ \ \ \ \ \ connected\_components++;}
\DoxyCodeLine{00086\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00087\ \ \ \ \ \}}
\DoxyCodeLine{00088\ \ \ \ \ \textcolor{keywordflow}{return}\ connected\_components;}
\DoxyCodeLine{00089\ \}}

\end{DoxyCode}
\Hypertarget{namespacegraph_a84b0551489c613a681cc83b34450da4b}\index{graph@{graph}!isBipartite@{isBipartite}}
\index{isBipartite@{isBipartite}!graph@{graph}}
\doxysubsubsection{\texorpdfstring{isBipartite()}{isBipartite()}}
{\footnotesize\ttfamily \label{namespacegraph_a84b0551489c613a681cc83b34450da4b} 
bool graph\+::is\+Bipartite (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ std\+::vector$<$ int64\+\_\+t $>$ $>$ \&}]{graph}{}\end{DoxyParamCaption})}



returns true if the given graph is bipartite else returns false 


\begin{DoxyParams}{Parameters}
{\em graph} & is a 2D matrix whose rows or the first index signify the node and values in that row signify the nodes it is connected to \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
booleans 
\end{DoxyReturn}
\texorpdfstring{$<$}{<} stores boolean values which signify whether that node had been visited or not

if the current node is not visited then check whether the sub-\/graph of that node is a bipartite or not
\begin{DoxyCode}{0}
\DoxyCodeLine{00075\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00076\ \ \ \ \ std::vector<int64\_t>\ visited(}
\DoxyCodeLine{00077\ \ \ \ \ \ \ \ \ \mbox{\hyperlink{namespacegraph}{graph}}.size());\ \ \textcolor{comment}{///<\ stores\ boolean\ values}\textcolor{comment}{}}
\DoxyCodeLine{00078\ \textcolor{comment}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ///\ which\ signify\ whether\ that\ node\ had\ been\ visited\ or}}
\DoxyCodeLine{00079\ \textcolor{comment}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ///\ not}}
\DoxyCodeLine{00080\ \textcolor{comment}{}}
\DoxyCodeLine{00081\ \ \ \ \ \textcolor{keywordflow}{for}\ (uint64\_t\ i\ =\ 0;\ i\ <\ \mbox{\hyperlink{namespacegraph}{graph}}.size();\ i++)\ \{}
\DoxyCodeLine{00082\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!visited[i])\ \ \textcolor{comment}{///\ if\ the\ current\ node\ is\ not\ visited\ then\ check}\textcolor{comment}{}}
\DoxyCodeLine{00083\ \textcolor{comment}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ///\ whether\ the\ sub-\/graph\ of\ that\ node\ is\ a\ bipartite}}
\DoxyCodeLine{00084\ \textcolor{comment}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ///\ or\ not}}
\DoxyCodeLine{00085\ \textcolor{comment}{}\ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00086\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!\mbox{\hyperlink{namespacegraph_a8e1b547cd407c0774e63f0dc95cda9e7}{checkBipartite}}(\mbox{\hyperlink{namespacegraph}{graph}},\ i,\ \&visited))\ \{}
\DoxyCodeLine{00087\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{00088\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00089\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00090\ \ \ \ \ \}}
\DoxyCodeLine{00091\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{00092\ \}}

\end{DoxyCode}
\Hypertarget{namespacegraph_ab7706341d006e20d1ae58274187a3346}\index{graph@{graph}!TravellingSalesmanProblem@{TravellingSalesmanProblem}}
\index{TravellingSalesmanProblem@{TravellingSalesmanProblem}!graph@{graph}}
\doxysubsubsection{\texorpdfstring{TravellingSalesmanProblem()}{TravellingSalesmanProblem()}}
{\footnotesize\ttfamily \label{namespacegraph_ab7706341d006e20d1ae58274187a3346} 
int graph\+::\+Travelling\+Salesman\+Problem (\begin{DoxyParamCaption}\item[{std\+::vector$<$ std\+::vector$<$ uint32\+\_\+t $>$ $>$ \texorpdfstring{$\ast$}{*}}]{cities}{, }\item[{int32\+\_\+t}]{src}{, }\item[{uint32\+\_\+t}]{V}{}\end{DoxyParamCaption})}



Function calculates the minimum path distance that will cover all the cities starting from the source. 


\begin{DoxyParams}{Parameters}
{\em cities} & matrix representation of cities \\
\hline
{\em src} & \doxylink{struct_point}{Point} from where salesman is starting \\
\hline
{\em V} & number of vertices in the graph \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{00041\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{\textcolor{comment}{}}
\DoxyCodeLine{00042\ \textcolor{comment}{\ \ \ \ ////\ vtx\ stores\ the\ vertexs\ of\ the\ graph}}
\DoxyCodeLine{00043\ \textcolor{comment}{}\ \ \ \ std::vector<uint32\_t>\ vtx;}
\DoxyCodeLine{00044\ \ \ \ \ \textcolor{keywordflow}{for}\ (uint32\_t\ i\ =\ 0;\ i\ <\ V;\ i++)\ \{}
\DoxyCodeLine{00045\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (i\ !=\ src)\ \{}
\DoxyCodeLine{00046\ \ \ \ \ \ \ \ \ \ \ \ \ vtx.push\_back(i);}
\DoxyCodeLine{00047\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00048\ \ \ \ \ \}}
\DoxyCodeLine{00049\ \textcolor{comment}{}}
\DoxyCodeLine{00050\ \textcolor{comment}{\ \ \ \ ////\ store\ minimum\ weight\ Hamiltonian\ Cycle.}}
\DoxyCodeLine{00051\ \textcolor{comment}{}\ \ \ \ int32\_t\ min\_path\ =\ 2147483647;}
\DoxyCodeLine{00052\ \ \ \ \ \textcolor{keywordflow}{do}\ \{\textcolor{comment}{}}
\DoxyCodeLine{00053\ \textcolor{comment}{\ \ \ \ \ \ \ \ ////\ store\ current\ Path\ weight(cost)}}
\DoxyCodeLine{00054\ \textcolor{comment}{}\ \ \ \ \ \ \ \ int32\_t\ curr\_weight\ =\ 0;}
\DoxyCodeLine{00055\ \textcolor{comment}{}}
\DoxyCodeLine{00056\ \textcolor{comment}{\ \ \ \ \ \ \ \ ////\ compute\ current\ path\ weight}}
\DoxyCodeLine{00057\ \textcolor{comment}{}\ \ \ \ \ \ \ \ \textcolor{keywordtype}{int}\ \mbox{\hyperlink{composite__simpson__rule_8cpp_a1b74d828b33760094906797042b89442}{k}}\ =\ src;}
\DoxyCodeLine{00058\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{int}\ i\ :\ vtx)\ \{}
\DoxyCodeLine{00059\ \ \ \ \ \ \ \ \ \ \ \ \ curr\_weight\ +=\ (*cities)[\mbox{\hyperlink{composite__simpson__rule_8cpp_a1b74d828b33760094906797042b89442}{k}}][i];}
\DoxyCodeLine{00060\ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{composite__simpson__rule_8cpp_a1b74d828b33760094906797042b89442}{k}}\ =\ i;}
\DoxyCodeLine{00061\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00062\ \ \ \ \ \ \ \ \ curr\_weight\ +=\ (*cities)[\mbox{\hyperlink{composite__simpson__rule_8cpp_a1b74d828b33760094906797042b89442}{k}}][src];}
\DoxyCodeLine{00063\ \textcolor{comment}{}}
\DoxyCodeLine{00064\ \textcolor{comment}{\ \ \ \ \ \ \ \ ////\ update\ minimum}}
\DoxyCodeLine{00065\ \textcolor{comment}{}\ \ \ \ \ \ \ \ min\_path\ =\ std::min(min\_path,\ curr\_weight);}
\DoxyCodeLine{00066\ }
\DoxyCodeLine{00067\ \ \ \ \ \}\ \textcolor{keywordflow}{while}\ (next\_permutation(vtx.begin(),\ vtx.end()));}
\DoxyCodeLine{00068\ }
\DoxyCodeLine{00069\ \ \ \ \ \textcolor{keywordflow}{return}\ min\_path;}
\DoxyCodeLine{00070\ \}}

\end{DoxyCode}
