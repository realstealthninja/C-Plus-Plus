<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Algorithms_in_C++: operations_on_datastructures/inorder_successor_of_bst.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Algorithms_in_C++<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">Set of algorithms implemented in C++.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_35422be6552f1b3672c1b6c4aba2da64.html">operations_on_datastructures</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">inorder_successor_of_bst.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>An implementation for finding the <a href="https://www.youtube.com/watch?v=5cPbNCrdotA">Inorder successor of a binary search tree</a> Inorder successor of a node is the next node in Inorder traversal of the Binary Tree. Inorder Successor is NULL for the last node in Inorder traversal.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;cassert&gt;</code><br />
<code>#include &lt;iostream&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for inorder_successor_of_bst.cpp:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="inorder__successor__of__bst_8cpp__incl.svg" width="252" height="126"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__on__datastructures_1_1inorder__traversal__of__bst_1_1_node.html">operations_on_datastructures::inorder_traversal_of_bst::Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classoperations__on__datastructures_1_1inorder__traversal__of__bst_1_1_node.html" title="A Node structure representing a single node in BST.">Node</a> structure representing a single node in BST.  <a href="classoperations__on__datastructures_1_1inorder__traversal__of__bst_1_1_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_test_cases.html">TestCases</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class encapsulating the necessary test cases  <a href="class_test_cases.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__on__datastructures.html">operations_on_datastructures</a></td></tr>
<tr class="memdesc:namespaceoperations__on__datastructures"><td class="mdescLeft">&#160;</td><td class="mdescRight">for std::vector <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinorder__successor__of__bst.html">inorder_successor_of_bst</a></td></tr>
<tr class="memdesc:namespaceinorder__successor__of__bst"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functions for the <a href="https://www.youtube.com/watch?v=5cPbNCrdotA">Inorder successor of a binary search tree</a> implementation. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7f6f73a33beec448c27cc1d70b220702" id="r_a7f6f73a33beec448c27cc1d70b220702"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__on__datastructures_1_1inorder__traversal__of__bst_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f6f73a33beec448c27cc1d70b220702">operations_on_datastructures::inorder_traversal_of_bst::makeNode</a> (int64_t <a class="el" href="hash__search_8cpp.html#a6e1a77282bc65ad359d753d25df23243">data</a>)</td></tr>
<tr class="memdesc:a7f6f73a33beec448c27cc1d70b220702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new node in heap for given data and returns it's pointer.  <br /></td></tr>
<tr class="separator:a7f6f73a33beec448c27cc1d70b220702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae0bea4123fd2ce155108e88f2ef78c" id="r_a3ae0bea4123fd2ce155108e88f2ef78c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__on__datastructures_1_1inorder__traversal__of__bst_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ae0bea4123fd2ce155108e88f2ef78c">operations_on_datastructures::inorder_traversal_of_bst::Insert</a> (<a class="el" href="classoperations__on__datastructures_1_1inorder__traversal__of__bst_1_1_node.html">Node</a> *root, int64_t <a class="el" href="hash__search_8cpp.html#a6e1a77282bc65ad359d753d25df23243">data</a>)</td></tr>
<tr class="memdesc:a3ae0bea4123fd2ce155108e88f2ef78c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given data in BST while maintaining the properties of BST.  <br /></td></tr>
<tr class="separator:a3ae0bea4123fd2ce155108e88f2ef78c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824cbf1814854824cf05f062eea07b95" id="r_a824cbf1814854824cf05f062eea07b95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__on__datastructures_1_1inorder__traversal__of__bst_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a824cbf1814854824cf05f062eea07b95">operations_on_datastructures::inorder_traversal_of_bst::getNode</a> (<a class="el" href="classoperations__on__datastructures_1_1inorder__traversal__of__bst_1_1_node.html">Node</a> *root, int64_t <a class="el" href="hash__search_8cpp.html#a6e1a77282bc65ad359d753d25df23243">data</a>)</td></tr>
<tr class="memdesc:a824cbf1814854824cf05f062eea07b95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the given data in BST and returns the pointer to the node containing that data.  <br /></td></tr>
<tr class="separator:a824cbf1814854824cf05f062eea07b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72483e3f6933e004a8d86371e8a990db" id="r_a72483e3f6933e004a8d86371e8a990db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__on__datastructures_1_1inorder__traversal__of__bst_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72483e3f6933e004a8d86371e8a990db">operations_on_datastructures::inorder_traversal_of_bst::findMinNode</a> (<a class="el" href="classoperations__on__datastructures_1_1inorder__traversal__of__bst_1_1_node.html">Node</a> *root)</td></tr>
<tr class="memdesc:a72483e3f6933e004a8d86371e8a990db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds and return the minimum node in BST.  <br /></td></tr>
<tr class="separator:a72483e3f6933e004a8d86371e8a990db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7266b934ca50c4f53e4f1e725d89a4" id="r_a5d7266b934ca50c4f53e4f1e725d89a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d7266b934ca50c4f53e4f1e725d89a4">operations_on_datastructures::inorder_traversal_of_bst::printInorder</a> (<a class="el" href="classoperations__on__datastructures_1_1inorder__traversal__of__bst_1_1_node.html">Node</a> *root)</td></tr>
<tr class="memdesc:a5d7266b934ca50c4f53e4f1e725d89a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the BST in inorder traversal using recursion.  <br /></td></tr>
<tr class="separator:a5d7266b934ca50c4f53e4f1e725d89a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05fe8a029e155c43e4efa598d4d089d9" id="r_a05fe8a029e155c43e4efa598d4d089d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__on__datastructures_1_1inorder__traversal__of__bst_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05fe8a029e155c43e4efa598d4d089d9">operations_on_datastructures::inorder_traversal_of_bst::makeBST</a> (<a class="el" href="classoperations__on__datastructures_1_1inorder__traversal__of__bst_1_1_node.html">Node</a> *root, const std::vector&lt; int64_t &gt; &amp;<a class="el" href="hash__search_8cpp.html#a6e1a77282bc65ad359d753d25df23243">data</a>)</td></tr>
<tr class="memdesc:a05fe8a029e155c43e4efa598d4d089d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used in test cases to quickly create BST containing large data instead of hard coding it in code. For a given root, this will add all the nodes containing data passes in data vector.  <br /></td></tr>
<tr class="separator:a05fe8a029e155c43e4efa598d4d089d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3923fb22b46e085376703cae0b44d690" id="r_a3923fb22b46e085376703cae0b44d690"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__on__datastructures_1_1inorder__traversal__of__bst_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3923fb22b46e085376703cae0b44d690">operations_on_datastructures::inorder_traversal_of_bst::getInorderSuccessor</a> (<a class="el" href="classoperations__on__datastructures_1_1inorder__traversal__of__bst_1_1_node.html">Node</a> *root, int64_t <a class="el" href="hash__search_8cpp.html#a6e1a77282bc65ad359d753d25df23243">data</a>)</td></tr>
<tr class="memdesc:a3923fb22b46e085376703cae0b44d690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inorder successor of a node is the next node in inorder traversal of the Binary Tree. This function takes the root node and the data of the node for which we have to find the inorder successor, and returns the inorder successor node.  <br /></td></tr>
<tr class="separator:a3923fb22b46e085376703cae0b44d690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b20eb99272665c1777949e26ab59589" id="r_a7b20eb99272665c1777949e26ab59589"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b20eb99272665c1777949e26ab59589">operations_on_datastructures::inorder_traversal_of_bst::deallocate</a> (<a class="el" href="classoperations__on__datastructures_1_1inorder__traversal__of__bst_1_1_node.html">Node</a> *rootNode)</td></tr>
<tr class="memdesc:a7b20eb99272665c1777949e26ab59589"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function clears the memory allocated to entire tree recursively. Its just for clean up the memory and not relevant to the actual topic.  <br /></td></tr>
<tr class="separator:a7b20eb99272665c1777949e26ab59589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ddf1224851353fc92bfbff6f499fa97" id="r_a0ddf1224851353fc92bfbff6f499fa97"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ddf1224851353fc92bfbff6f499fa97">main</a> (int argc, char *argv[])</td></tr>
<tr class="memdesc:a0ddf1224851353fc92bfbff6f499fa97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main function.  <br /></td></tr>
<tr class="separator:a0ddf1224851353fc92bfbff6f499fa97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An implementation for finding the <a href="https://www.youtube.com/watch?v=5cPbNCrdotA">Inorder successor of a binary search tree</a> Inorder successor of a node is the next node in Inorder traversal of the Binary Tree. Inorder Successor is NULL for the last node in Inorder traversal. </p>
<h3><a class="anchor" id="autotoc_md88"></a>
Case 1: The given node has the right node/subtree</h3>
<pre class="fragment"> * In this case, the left-most deepest node in the right subtree will
</pre><p> come just after the given node as we go to left deep in inorder.</p><ul>
<li>Go deep to left most node in right subtree. OR, we can also say in case if BST, find the minimum of the subtree for a given node.</li>
</ul>
<h3><a class="anchor" id="autotoc_md89"></a>
Case 2: The given node does not have a right node/subtree</h3>
<h4><a class="anchor" id="autotoc_md90"></a>
Method 1: Use parent pointer (store the address of parent nodes)</h4>
<ul>
<li>If a node does not have the right subtree, and we already visited the node itself, then the next node will be its parent node according to inorder traversal, and if we are going to parent from left, then the parent would be unvisited.</li>
<li>In other words, go to the nearest ancestor for which given node would be in left subtree.</li>
</ul>
<h4><a class="anchor" id="autotoc_md91"></a>
Method 2: Search from the root node</h4>
<ul>
<li>In case if there is no link from a child node to the parent node, we need to walk down the tree starting from the root node to the given node, by doing so, we are visiting every ancestor of the given node.</li>
<li>In order successor would be the deepest node in this path for which given node is in left subtree.</li>
</ul>
<dl class="section author"><dt>Author</dt><dd><a href="https://github.com/foo290">Nitin Sharma</a> </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a7b20eb99272665c1777949e26ab59589" name="a7b20eb99272665c1777949e26ab59589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b20eb99272665c1777949e26ab59589">&#9670;&#160;</a></span>deallocate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_on_datastructures::inorder_traversal_of_bst::deallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__on__datastructures_1_1inorder__traversal__of__bst_1_1_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>rootNode</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function clears the memory allocated to entire tree recursively. Its just for clean up the memory and not relevant to the actual topic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Root node of the tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="inorder__successor__of__bst_8cpp_a7b20eb99272665c1777949e26ab59589_cgraph.svg" width="203" height="91"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a72483e3f6933e004a8d86371e8a990db" name="a72483e3f6933e004a8d86371e8a990db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72483e3f6933e004a8d86371e8a990db">&#9670;&#160;</a></span>findMinNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_node.html">Node</a> * operations_on_datastructures::inorder_traversal_of_bst::findMinNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__on__datastructures_1_1inorder__traversal__of__bst_1_1_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds and return the minimum node in BST. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>A pointer to root node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Node* Pointer to the found node </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="inorder__successor__of__bst_8cpp_a72483e3f6933e004a8d86371e8a990db_cgraph.svg" width="203" height="91"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a3923fb22b46e085376703cae0b44d690" name="a3923fb22b46e085376703cae0b44d690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3923fb22b46e085376703cae0b44d690">&#9670;&#160;</a></span>getInorderSuccessor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_node.html">Node</a> * operations_on_datastructures::inorder_traversal_of_bst::getInorderSuccessor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__on__datastructures_1_1inorder__traversal__of__bst_1_1_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inorder successor of a node is the next node in inorder traversal of the Binary Tree. This function takes the root node and the data of the node for which we have to find the inorder successor, and returns the inorder successor node. </p>
<p>Search from the root node as we need to walk the tree starting from the root node to the given node, by doing so, we are visiting every ancestor of the given node. In order successor would be the deepest node in this path for which given node is in left subtree. Time complexity O(h) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>A pointer to the root node of the BST </td></tr>
    <tr><td class="paramname">data</td><td>The data (or the data of node) for which we have to find inorder successor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_node.html">Node</a> pointer to the inorder successor node. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="inorder__successor__of__bst_8cpp_a3923fb22b46e085376703cae0b44d690_cgraph.svg" width="444" height="195"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a824cbf1814854824cf05f062eea07b95" name="a824cbf1814854824cf05f062eea07b95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a824cbf1814854824cf05f062eea07b95">&#9670;&#160;</a></span>getNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_node.html">Node</a> * operations_on_datastructures::inorder_traversal_of_bst::getNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__on__datastructures_1_1inorder__traversal__of__bst_1_1_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches the given data in BST and returns the pointer to the node containing that data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Pointer to the root node of the BST </td></tr>
    <tr><td class="paramname">data</td><td>Data to be Searched. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Node* pointer to the found node </dd></dl>
<p><a class="el" href="struct_node.html">Node</a> found!</p>
<p>Traverse right subtree recursively as the given data is greater than the data in root node, data must be present in right subtree.</p>
<p>Traverse left subtree recursively as the given data is less than the data in root node, data must be present in left subtree.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="inorder__successor__of__bst_8cpp_a824cbf1814854824cf05f062eea07b95_cgraph.svg" width="203" height="91"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a3ae0bea4123fd2ce155108e88f2ef78c" name="a3ae0bea4123fd2ce155108e88f2ef78c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae0bea4123fd2ce155108e88f2ef78c">&#9670;&#160;</a></span>Insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_node.html">Node</a> * operations_on_datastructures::inorder_traversal_of_bst::Insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__on__datastructures_1_1inorder__traversal__of__bst_1_1_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the given data in BST while maintaining the properties of BST. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Pointer to the root node of the BST </td></tr>
    <tr><td class="paramname">data</td><td>Data to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Node* Pointer to the root node. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="inorder__successor__of__bst_8cpp_a3ae0bea4123fd2ce155108e88f2ef78c_cgraph.svg" width="444" height="91"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a0ddf1224851353fc92bfbff6f499fa97" name="a0ddf1224851353fc92bfbff6f499fa97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ddf1224851353fc92bfbff6f499fa97">&#9670;&#160;</a></span>main()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int main </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>argc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>argv</em></span>[]&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">argc</td><td>commandline argument count (ignored) </td></tr>
    <tr><td class="paramname">argv</td><td>commandline array of arguments (ignored) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on exit </dd></dl>
<p>&lt; root node of the bst</p>
<p>&lt; Data to add nodes in BST</p>
<p>&lt; An element to find inorder successor for.</p>
<p>&lt; Making BST</p>
<p>memory cleanup!</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="inorder__successor__of__bst_8cpp_a0ddf1224851353fc92bfbff6f499fa97_cgraph.svg" width="152" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a05fe8a029e155c43e4efa598d4d089d9" name="a05fe8a029e155c43e4efa598d4d089d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05fe8a029e155c43e4efa598d4d089d9">&#9670;&#160;</a></span>makeBST()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_node.html">Node</a> * operations_on_datastructures::inorder_traversal_of_bst::makeBST </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__on__datastructures_1_1inorder__traversal__of__bst_1_1_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int64_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used in test cases to quickly create BST containing large data instead of hard coding it in code. For a given root, this will add all the nodes containing data passes in data vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>Pointer to the root node. </td></tr>
    <tr><td class="paramname">data</td><td>A vector containing integer values which are suppose to be inserted as nodes in BST. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_node.html">Node</a> pointer to the root node. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="inorder__successor__of__bst_8cpp_a05fe8a029e155c43e4efa598d4d089d9_cgraph.svg" width="203" height="91"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a7f6f73a33beec448c27cc1d70b220702" name="a7f6f73a33beec448c27cc1d70b220702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f6f73a33beec448c27cc1d70b220702">&#9670;&#160;</a></span>makeNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_node.html">Node</a> * operations_on_datastructures::inorder_traversal_of_bst::makeNode </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a new node in heap for given data and returns it's pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Data for the node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly allocated <a class="el" href="struct_node.html">Node</a>. </dd></dl>
<p>&lt; setting data for node</p>
<p>&lt; setting left child as null</p>
<p>&lt; setting right child as null</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="inorder__successor__of__bst_8cpp_a7f6f73a33beec448c27cc1d70b220702_cgraph.svg" width="203" height="91"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a5d7266b934ca50c4f53e4f1e725d89a4" name="a5d7266b934ca50c4f53e4f1e725d89a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d7266b934ca50c4f53e4f1e725d89a4">&#9670;&#160;</a></span>printInorder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_on_datastructures::inorder_traversal_of_bst::printInorder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__on__datastructures_1_1inorder__traversal__of__bst_1_1_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the BST in inorder traversal using recursion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>A pointer to the root node of the BST. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<p>recursive call to left subtree</p>
<p>recursive call to right subtree</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="inorder__successor__of__bst_8cpp_a5d7266b934ca50c4f53e4f1e725d89a4_cgraph.svg" width="203" height="91"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
